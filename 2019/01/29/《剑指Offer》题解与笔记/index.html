<!DOCTYPE html>
<html lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="水木今山">


    <meta name="subtitle" content="Coding the World">


    <meta name="description" content="Coding the World">


    <meta name="keywords" content="blog,hecenjie">


<title>《剑指Offer》题解与笔记 | 水木今山的博客</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


</head>
<body>
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">水木今山的博客</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/">Home</a>
                
                    <a class="menu-item" href="/archives/">Archives</a>
                
                    <a class="menu-item" href="/column/">Column</a>
                
                    <a class="menu-item" href="/tag/">Tags</a>
                
                    <a class="menu-item" href="/about/">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">水木今山的博客</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/">Home</a>
                
                    <a class="menu-item" href="/archives/">Archives</a>
                
                    <a class="menu-item" href="/column/">Column</a>
                
                    <a class="menu-item" href="/tag/">Tags</a>
                
                    <a class="menu-item" href="/about/">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
        <div class="main">
            <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "Collapse all"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "Expand all"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">《剑指Offer》题解与笔记</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">水木今山</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">January 29, 2019&nbsp;&nbsp;19:16:00</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/算法/">算法</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <h2 id="3-1-找出数组中重复的数字"><a href="#3-1-找出数组中重复的数字" class="headerlink" title="3.1 找出数组中重复的数字"></a>3.1 找出数组中重复的数字</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。</p>
<a id="more"></a>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>对数组进行移位，判断i下标的数字等于i，如果不等则对其进行交换，eg:</p>
<p>{<strong>1</strong>，<strong>3</strong>，4，6，5，2，5} –&gt;  {3，1，4，6，5，2，5}  //下标为0的数字为1，因此将下标为1的数字即3与1换位，使得1到了其应在的地方</p>
<p>{<strong>3</strong>，1，4，<strong>6</strong>，5，2，5}  –&gt; {6，1，4，3，5，2，5}  //此时下标为0的数字为3，依然不等于其下标，因此找到下标为3的数字6与其交换，使3到了其应在的地方</p>
<p>{<strong>6</strong>，1，4，3，5，2，<strong>5</strong>} –&gt; {5，1，4，3，5，2，6}     //同理</p>
<p>{<strong>5</strong>，1，4，3，5，<strong>2</strong>，6} –&gt; {2，1，4，3，5，5，6} </p>
<p>{<strong>2</strong>，1，<strong>4</strong>，3，5，5，6} –&gt; {4，1，2，3，5，5，6}</p>
<p>{<strong>4</strong>，1，2，3，<strong>5</strong>，5，6} –&gt; {5，1，2，3，4，5，6}</p>
<p>{<strong>5</strong>，1，2，3，4，<strong>5</strong>，6}     //此时，要交换的两个数字相等，则证明该数字重复</p>
<p>可以看出，其时间复杂度为O(n)，且不需要额外分配空间，空间复杂度为O(1)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Parameters:</span></span><br><span class="line">    <span class="comment">//    numbers:     an array of integers</span></span><br><span class="line">    <span class="comment">//    length:      the length of array numbers</span></span><br><span class="line">    <span class="comment">//    duplication: (Output) the duplicated number in the array number,length of duplication array is 1,so using duplication[0] = ? in implementation;</span></span><br><span class="line">    <span class="comment">//                  Here duplication like pointor in C/C++, duplication[0] equal *duplication in C/C++</span></span><br><span class="line">    <span class="comment">//    这里要特别注意~返回任意重复的一个，赋值duplication[0]</span></span><br><span class="line">    <span class="comment">// Return value:       true if the input is valid, and there are some duplications in the array number</span></span><br><span class="line">    <span class="comment">//                     otherwise false</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span> numbers[],<span class="keyword">int</span> length,<span class="keyword">int</span> [] duplication)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(numbers == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)&#123;</span><br><span class="line">           <span class="keyword">while</span>(numbers[i] != i)&#123;</span><br><span class="line">               <span class="keyword">if</span>(numbers[i] == numbers[numbers[i]])&#123;</span><br><span class="line">                   duplication[<span class="number">0</span>] = numbers[i];</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               swap(numbers, numbers[i], i);</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = numbers[a];</span><br><span class="line">        numbers[a] = numbers[b];</span><br><span class="line">        numbers[b] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-2-不修改数组找出重复的数字"><a href="#3-2-不修改数组找出重复的数字" class="headerlink" title="3.2 不修改数组找出重复的数字"></a>3.2 不修改数组找出重复的数字</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>在一个长度为n+1的数组里的所有数字都在1~n的范围内，所以数组中至少有一个数字是重复的。请找出数组中任意一个重复的数字，但不能修改输入的数组。例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。</p>
<h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>此道题与上题类似，但有不同的几点：</p>
<p>1、题目要求不能修改输入的数组，因此可能要考虑创建辅助数组，这里的一个思路是将原数组的数字m移动到辅助数组中下标为m的位置，因此当移动时检测到辅助数组该下标已经有数字时，表示此数字重复了。这里的的空间复杂度为O(n)，时间复杂度为O(n)。</p>
<p>2、题目中提到“在一个长度为n+1的数组里的所有数字都在1-n的范围内”，例如，若有个包含5个数的数组，但里面的数字只有1、2、3、4，那么必然有一个是重复的。这时候另一个思路则是在1、2、3、4、5中找出中间数3，以此将数组分割成两块，左半块是1-3（注意不是1-2），右半块是4-5，之后遍历整个数组，若数字在左半边的范围内，则将计数器加一。结束遍历时，若计数器的值大于这边块包含的个数，就说明重复的数字在这边块里，否则其就在右半块。紧接着把范围缩小到其中一边，继续重复以上操作。此操作类似二分查找法，需要的时间为O(nlogn)，空间复杂度为o(1)，相当于以时间换空间。下面给出的代码将根据此种思路。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Parameters:</span></span><br><span class="line">    <span class="comment">//    numbers:     an array of integers</span></span><br><span class="line">    <span class="comment">//    length:      the length of array numbers</span></span><br><span class="line">    <span class="comment">//    duplication: (Output) the duplicated number in the array number,length of duplication array is 1,so using duplication[0] = ? in implementation;</span></span><br><span class="line">    <span class="comment">//                  Here duplication like pointor in C/C++, duplication[0] equal *duplication in C/C++</span></span><br><span class="line">    <span class="comment">//    这里要特别注意~返回任意重复的一个，赋值duplication[0]</span></span><br><span class="line">    <span class="comment">// Return value:       true if the input is valid, and there are some duplications in the array number</span></span><br><span class="line">    <span class="comment">//                     otherwise false</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span> numbers[],<span class="keyword">int</span> length,<span class="keyword">int</span> [] duplication)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(numbers == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> end = length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(end &gt;= start)&#123;</span><br><span class="line">            <span class="keyword">int</span> middle = (end - start) / <span class="number">2</span> + start;</span><br><span class="line">            <span class="keyword">int</span> count = countRange(numbers, length, start, middle);</span><br><span class="line">            <span class="keyword">if</span>(end == start)&#123;</span><br><span class="line">                <span class="keyword">if</span>(count &gt; <span class="number">1</span>)&#123;</span><br><span class="line">                    duplication[<span class="number">0</span>] = start;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(count &gt; middle - start + <span class="number">1</span>)</span><br><span class="line">                end = middle;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                start = middle + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countRange</span><span class="params">(<span class="keyword">int</span> numbers[],<span class="keyword">int</span> length, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(numbers == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(numbers[i] &gt;= start &amp;&amp; numbers[i] &lt;= end)&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-二维数组中的查找"><a href="#4-二维数组中的查找" class="headerlink" title="4.二维数组中的查找"></a>4.二维数组中的查找</h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span> [][] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = array.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; array[<span class="number">0</span>].length &amp;&amp; len &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[len][i] &gt; target)&#123;</span><br><span class="line">                len--;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(array[len][i] &lt; target)&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-替换空格"><a href="#5-替换空格" class="headerlink" title="5.替换空格"></a>5.替换空格</h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p>
<h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><p>先遍历一次字符串，得到空格的总数，然后将字符串的长度设置为字符串的原长度加上空格数的两倍。将原始字符串末尾的值不断复制给新新字符串的末尾，每次遇到空格的时候在新字符串前插入%20。此算法中所有字符都只复制了一次，因此时间复杂度为O(n)。</p>
<p>在合并两个数组时，如果从前往后复制每个数字（或字符）则需要重复移动数字（或字符）多次，那么我们可以考虑从后往前复制，这样就能减少移动的次数，从而提高效率。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(StringBuffer str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> spaceNum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str.charAt(i) == <span class="string">' '</span>)&#123;</span><br><span class="line">                spaceNum++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> oldIndex = str.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> newLength = str.length() + spaceNum * <span class="number">2</span>;</span><br><span class="line">        str.setLength(newLength);</span><br><span class="line">        <span class="keyword">int</span> newIndex = newLength - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(; oldIndex &gt;= <span class="number">0</span> &amp;&amp; oldIndex &lt;= newIndex; oldIndex--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str.charAt(oldIndex) == <span class="string">' '</span>) &#123;</span><br><span class="line">                str.setCharAt(newIndex--, <span class="string">'0'</span>);</span><br><span class="line">                str.setCharAt(newIndex--, <span class="string">'2'</span>);</span><br><span class="line">                str.setCharAt(newIndex--, <span class="string">'%'</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                str.setCharAt(newIndex--, str.charAt(oldIndex));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-从尾到头打印链表"><a href="#6-从尾到头打印链表" class="headerlink" title="6.从尾到头打印链表"></a>6.从尾到头打印链表</h2><h3 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*    public class ListNode &#123;</span></span><br><span class="line"><span class="comment">*        int val;</span></span><br><span class="line"><span class="comment">*        ListNode next = null;</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*        ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">*            this.val = val;</span></span><br><span class="line"><span class="comment">*        &#125;</span></span><br><span class="line"><span class="comment">*    &#125;</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h3><h4 id="使用递归"><a href="#使用递归" class="headerlink" title="使用递归"></a>使用递归</h4><p>每访问到一个节点的时候，先递归输出它后面的节点，再输出该节点自身。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(listNode != <span class="keyword">null</span>)&#123;</span><br><span class="line">            arrayList.addAll(printListFromTailToHead(listNode.nextNode));</span><br><span class="line">            arrayList.add(listNode.val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arrayList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用栈"><a href="#使用栈" class="headerlink" title="使用栈"></a>使用栈</h4><p>利用栈“先进后出”的特性，实现最先入栈的节点值最后输出。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">    Stack stack = <span class="keyword">new</span> Stack();</span><br><span class="line">    <span class="keyword">while</span>(listNode != <span class="keyword">null</span>)&#123;</span><br><span class="line">        stack.push(listNode.val);</span><br><span class="line">        listNode = listNode.nextNode;</span><br><span class="line">    &#125;</span><br><span class="line">    ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">        arrayList.add((Integer) stack.pop());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arrayList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="7-重建二叉树"><a href="#7-重建二叉树" class="headerlink" title="7.重建二叉树"></a>7.重建二叉树</h2><h3 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for binary tree</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>
<h3 id="题解-5"><a href="#题解-5" class="headerlink" title="题解"></a>题解</h3><p>对于前序遍历，第一个数字即为根节点的值；对于中序遍历，根据根节点值将序列划分为左右子树。接下来使用递归分别继续进行如上操作，便可不断构建出左右子树。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span> [] pre,<span class="keyword">int</span> [] in)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pre == <span class="keyword">null</span> || in == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> reConstructBinaryTree(pre, <span class="number">0</span>, pre.length-<span class="number">1</span>, in, <span class="number">0</span>, in.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span>[] pre, <span class="keyword">int</span> startPre, <span class="keyword">int</span> endPre, <span class="keyword">int</span>[] in, <span class="keyword">int</span> startIn, <span class="keyword">int</span> endIn)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(startPre &gt; endPre || startIn &gt; endIn)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(pre[startPre]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = startIn; i &lt;= endIn; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(in[i] == pre[startPre])&#123;</span><br><span class="line">                root.left = reConstructBinaryTree(pre, startPre+<span class="number">1</span>, i-startIn+startPre, in, startIn, i-<span class="number">1</span>);</span><br><span class="line">                root.right = reConstructBinaryTree(pre, startPre+i-startIn+<span class="number">1</span>, endPre, in, i+<span class="number">1</span>, endIn);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="8-二叉树的下一个节点"><a href="#8-二叉树的下一个节点" class="headerlink" title="8.二叉树的下一个节点"></a>8.二叉树的下一个节点</h2><h3 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">public class TreeLinkNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeLinkNode left = null;</span><br><span class="line">    TreeLinkNode right = null;</span><br><span class="line">    TreeLinkNode next = null;</span><br><span class="line"></span><br><span class="line">    TreeLinkNode(int val) &#123;</span><br><span class="line">        this.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<h3 id="题解-6"><a href="#题解-6" class="headerlink" title="题解"></a>题解</h3><p>此题可分为两种情况：一种是一个节点有右子树，那么它的下一个节点就是它的右子树中的最左子节点；另一种是没有右子树，那么就判断它是否为父节点的左节点，如果是，则父结点为其下一个节点，如果不是，则向上遍历其父结点，找到为其祖先节点左节点的父结点，这个祖先节点就是它的下一个节点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeLinkNode <span class="title">GetNext</span><span class="params">(TreeLinkNode pNode)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//1、一个节点有右子树，那么找到右子树的最左子节点</span></span><br><span class="line">        <span class="keyword">if</span> (pNode.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            TreeLinkNode node = pNode.right;</span><br><span class="line">            <span class="keyword">while</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                node = node.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2、一个节点没有右子树</span></span><br><span class="line">        <span class="keyword">while</span> (pNode.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(pNode.next.left == pNode) <span class="keyword">return</span> pNode.next;</span><br><span class="line">            pNode = pNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="9-用两个栈实现队列"><a href="#9-用两个栈实现队列" class="headerlink" title="9.用两个栈实现队列"></a>9.用两个栈实现队列</h2><h3 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h3><p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p>
<h3 id="题解-7"><a href="#题解-7" class="headerlink" title="题解"></a>题解</h3><p>此题思路较为简单，主要就是利用栈“先入后出”和队列“先入先出”的特性，每次push的时候将值存到栈1中，pop的时候先将栈1的值放入栈2从而实现逆序，然后再对栈2进行pop操作，就实现了队列的“先进先出”。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stack2.size() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (stack1.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                stack2.push(stack1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="10-1-斐波那契数列"><a href="#10-1-斐波那契数列" class="headerlink" title="10.1 斐波那契数列"></a>10.1 斐波那契数列</h2><h3 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h3><p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。</p>
<h3 id="题解-8"><a href="#题解-8" class="headerlink" title="题解"></a>题解</h3><p>传统的做法是使用递归：return Fibonacci(n-1)+Fibonacci(n-2)。但是这种做法画出树形图就能看出有许多重复的节点，而且容易导致内存溢出，因而不建议使用。</p>
<h4 id="使用循环"><a href="#使用循环" class="headerlink" title="使用循环"></a>使用循环</h4><p>使用循环是一个较好的做法，不仅提高了时间效率，也解决了内存溢出的问题。实际上，任何递归都可以用循环来实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> num1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> num2 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            num = num1 + num2;</span><br><span class="line">            num1 = num2;</span><br><span class="line">            num2 = num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用尾递归"><a href="#使用尾递归" class="headerlink" title="使用尾递归"></a>使用尾递归</h4><p>尾递归是递归的一种特殊形式，本质上和递归没有什么区别，但优化后可以重复利用同一个栈帧，大幅提高效率，具体介绍在我的博客中有介绍：。由于java没有对尾递归进行优化，所以在此题中用java解题时依旧无法解决内存溢出的问题，主要提供一种答题思路。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public int Fibonacci(int n) &#123;</span><br><span class="line">        return Fibonacci(n, 0, 1);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private static int Fibonacci(int n, int num1, int num2)&#123;</span><br><span class="line">        if(n == 0)</span><br><span class="line">            return 0;</span><br><span class="line">        if(n == 1)</span><br><span class="line">            return num2;</span><br><span class="line">        else</span><br><span class="line">            return Fibonacci(n - 1, num2, num1 + num2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="10-2-跳台阶"><a href="#10-2-跳台阶" class="headerlink" title="10.2 跳台阶"></a>10.2 跳台阶</h2><h3 id="题目描述-9"><a href="#题目描述-9" class="headerlink" title="题目描述"></a>题目描述</h3><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</p>
<h3 id="题解-9"><a href="#题解-9" class="headerlink" title="题解"></a>题解</h3><p>如果只有1级台阶，则只有一种跳法；如果有2级台阶，则可以一次跳两阶，或者一次跳一阶；如果有n级台阶，第一次跳就有两种不同的选择：当第一次只跳一阶时，总的跳法数等于后面n-1级台阶的跳法数，而如果第一次跳两阶的话，总的跳法数就等于后面n-2级台阶的跳法数。根据此规律可以得到以下公式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f(n) = 0, 当n=0时</span><br><span class="line">f(n) = 1, 当n=1时</span><br><span class="line">f(n) = 2, 当n=2时</span><br><span class="line">f(n) = f(n-1) + f(n-2), 当n&gt;2时</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloor</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> num1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> num2 = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            num = num1 + num2;</span><br><span class="line">            num1 = num2;</span><br><span class="line">            num2 = num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="10-3-变态跳台阶"><a href="#10-3-变态跳台阶" class="headerlink" title="10.3 变态跳台阶"></a>10.3 变态跳台阶</h2><h3 id="题目描述-10"><a href="#题目描述-10" class="headerlink" title="题目描述"></a>题目描述</h3><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p>
<h3 id="题解-10"><a href="#题解-10" class="headerlink" title="题解"></a>题解</h3><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><p>此题和上题类似，但是一次可以跳多级台阶，依旧可以根据“第一次跳多少台阶，则跳法数等于剩下多少台阶的跳法数目”的思路进行分析，因此我们可以如下分析：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">如果有1级台阶，则有f(1) = 1 种跳法</span><br><span class="line">如果有2级台阶，则有f(2) = f(2-1) + f(2-2) = 2 种跳法</span><br><span class="line">如果有3级台阶，则有f(3) = f(3-1) + f(3-2) + f(3-3) = 4 种跳法</span><br><span class="line">···</span><br><span class="line">如果有n级台阶，则有f(n) = f(n-1) + f(n-2) + f(n-3) + ··· + f(0) 种跳法</span><br><span class="line">              又 f(n-1) = f(n-2) + f(n-3) + f(n-4) + ··· + f(0)</span><br><span class="line">     进行相减可得，f(n) - f(n-1) = f(n-1)</span><br><span class="line">              即，f(n) = 2f(n-1)</span><br><span class="line">              </span><br><span class="line">由此得出，</span><br><span class="line">f(n) = 1, 当n=0时</span><br><span class="line">f(n) = 1, 当n=1时</span><br><span class="line">f(n) = f(n-1) + f(n-2), 当n&gt;=2时</span><br></pre></td></tr></table></figure>
<p>此题一个比较难理解的部分是，在公式中当n=0时，f(n)应当等于1而不是0。因为如果第一次就跳完了所有台阶，这也算一种跳法，此时f(n-n)=f(0)应当等于1而非0。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloorII</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> num1 = <span class="number">1</span>;   <span class="comment">//初始值应为1而非0</span></span><br><span class="line">        <span class="keyword">int</span> num2 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            num = num1 + num2;</span><br><span class="line">            num2 = num1;</span><br><span class="line">            num1 = num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h4><p>在跳台阶的整个过程中，除了最后一阶是必须要跳的，其它每个台阶都有跳或者不跳两种可能性，因此f(n) = 2^(n-1)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloorII</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">int</span>)Math.pow(<span class="number">2</span>, n-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="10-4-矩形覆盖"><a href="#10-4-矩形覆盖" class="headerlink" title="10.4 矩形覆盖"></a>10.4 矩形覆盖</h2><h3 id="题目描述-11"><a href="#题目描述-11" class="headerlink" title="题目描述"></a>题目描述</h3><p>我们可以用2 <em> 1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2 </em> 1的小矩形无重叠地覆盖一个2 * n的大矩形，总共有多少种方法？</p>
<h3 id="题解-11"><a href="#题解-11" class="headerlink" title="题解"></a>题解</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f(n) = 1, 当n=0时</span><br><span class="line">f(n) = 1, 当n=1时</span><br><span class="line">f(n) = f(n-1) + f(n-2), 当n&gt;=2时</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">RectCover</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> num1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> num2 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            num = num1 + num2;</span><br><span class="line">            num2 = num1;</span><br><span class="line">            num1 = num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="14-剪绳子"><a href="#14-剪绳子" class="headerlink" title="14 剪绳子"></a>14 剪绳子</h2><h3 id="题目描述-12"><a href="#题目描述-12" class="headerlink" title="题目描述"></a>题目描述</h3><p>一根长度为n的绳子，将绳子剪为m段（剪m-1次），每段绳子的长度为k[0] - k[m]；要求k[0] <em> k[1] </em> k[2] <em> ··· </em> k[m]的乘积为最大。n &gt;1 且 m&gt; 1。</p>
<h3 id="题解-12"><a href="#题解-12" class="headerlink" title="题解"></a>题解</h3><p>这道题可以采用动态规划来做。在剪第一刀的时候，我们有n-1种可能的选择，因此f(n)=max(f(i) * f(n-i))。由于递归会产生很多重复的子问题，因此采用由下而上的循环方式，将每个子问题的最优解放到数组dp里。最终的答案就是dp[n]。</p>
<p>在刚开始看书的时候并不理解为什么要对dp[1], dp[2], [dp3]逐一初始化，后来经过反复调试并思考，发现当n&gt;3时dp[3]也就是当绳子长度为3时，不应该对其进行切割，因为切割后理论应得问题最优解就是2，而它的父问题要想得到最优解，应该直接使用整段未切割绳子也就是3。而当n&lt;=3时，将在方法最开始就进行了一个正确的返回，即当绳子长度为3时，对其进行切割得到最优解为2。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">integerBreak</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> []dp = <span class="keyword">new</span> <span class="keyword">int</span>[n +<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        dp[<span class="number">3</span>] = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">4</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="comment">//把长度为i的绳子切成若干段</span></span><br><span class="line">            <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i/<span class="number">2</span>; j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> p = dp[j] * dp[i-j];</span><br><span class="line">                <span class="keyword">if</span>(max &lt; p)</span><br><span class="line">                    max = p;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i] = max;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="15-二进制中1的个数"><a href="#15-二进制中1的个数" class="headerlink" title="15 二进制中1的个数"></a>15 二进制中1的个数</h2><h3 id="题目描述-13"><a href="#题目描述-13" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个整数，输出该数二进制表示中1的个数。</p>
<h3 id="题解-13"><a href="#题解-13" class="headerlink" title="题解"></a>题解</h3><h4 id="常规解法"><a href="#常规解法" class="headerlink" title="常规解法"></a>常规解法</h4><p>将输入的数字n与1做与运算，如果得出的结果是1，说明n的最低位是1，从而将计数器加一，并将1左移，进行n的次低位的判断，如此反复。这种做法整数为多少位就要循环多少次。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(flag != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>((n &amp; flag) != <span class="number">0</span>)&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            flag = flag &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="优化解法"><a href="#优化解法" class="headerlink" title="优化解法"></a>优化解法</h4><p>对输入的数字n减1再与自身进行与运算，即(n-1)&amp;n可以将n最低位的1变成0：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">n:       11101100</span><br><span class="line">n-1:     11101011</span><br><span class="line">n&amp;(n-1): 11101000</span><br></pre></td></tr></table></figure></p>
<p>基于以上，n中有多少个1，就可以进行多少次这样的操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">0</span>)&#123;</span><br><span class="line">            count++;</span><br><span class="line">            n = (n - <span class="number">1</span>) &amp; n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="16-数值的整数次方"><a href="#16-数值的整数次方" class="headerlink" title="16 数值的整数次方"></a>16 数值的整数次方</h2><h3 id="题目描述-14"><a href="#题目描述-14" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。</p>
<h3 id="题解-14"><a href="#题解-14" class="headerlink" title="题解"></a>题解</h3><p>此题的关键在于对base、exponent为正数、负数和零的考虑。</p>
<h4 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> isNegative = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(exponent &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            isNegative = <span class="keyword">true</span>;</span><br><span class="line">            exponent = -exponent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> result = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= exponent; i++)&#123;</span><br><span class="line">            result = base * result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isNegative ? <span class="number">1</span> / result : result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><p>a的n次方可以通过如下公式求解：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a^n = a^(n/2) * a^(n/2),              n为偶数</span><br><span class="line">a^n = a^((n-1)/2) * a^((n-1)/2) * a,  n为奇数</span><br></pre></td></tr></table></figure>
<p>每次计算n都会变为原来的1/2，因此通过递归算法可以使时间复杂度降到logn，效率得到提升。除此之外，可以用右移运算和位与运算代替除2和求余运算两个操作，从而得到进一步优化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(exponent == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(exponent == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> base;</span><br><span class="line">        <span class="keyword">boolean</span> isNegative = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(exponent &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            isNegative = <span class="keyword">true</span>;</span><br><span class="line">            exponent = -exponent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> result = Power(base, exponent &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        result *= result;</span><br><span class="line">        <span class="keyword">if</span>((exponent &amp; <span class="number">0x1</span>) == <span class="number">1</span>)&#123;</span><br><span class="line">            result *= base;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(exponent &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            result = <span class="number">1</span> / result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isNegative ? <span class="number">1</span> / result : result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="17-打印从1到最大的n位数"><a href="#17-打印从1到最大的n位数" class="headerlink" title="17 打印从1到最大的n位数"></a>17 打印从1到最大的n位数</h2><h3 id="题目描述-15"><a href="#题目描述-15" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入数字n，按顺序打印出从1到最大的n位十进制数。比如输入3，则打印出1、2、3一直到最大的3位数999。</p>
<h3 id="题解-15"><a href="#题解-15" class="headerlink" title="题解"></a>题解</h3><p>这道题可以使用递归对n位数进行全排列，在每一次递归调用之前都设置好下一位，当index为最后一位时，结束递归并打印。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrintToMaxOfNDigits</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">char</span>[] nums = <span class="keyword">new</span> <span class="keyword">char</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">            nums[<span class="number">0</span>] = (<span class="keyword">char</span>) (<span class="string">'0'</span> + i);</span><br><span class="line">            PrintToMaxOfNDigits(nums, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrintToMaxOfNDigits</span><span class="params">(<span class="keyword">char</span>[] nums, <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index == nums.length - <span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(nums);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">            nums[index+<span class="number">1</span>] = (<span class="keyword">char</span>) (<span class="string">'0'</span> + i);</span><br><span class="line">            PrintToMaxOfNDigits(nums, index+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="18-1-在O-1-时间内删除链表节点"><a href="#18-1-在O-1-时间内删除链表节点" class="headerlink" title="18.1 在O(1)时间内删除链表节点"></a>18.1 在O(1)时间内删除链表节点</h2><h3 id="题目描述-16"><a href="#题目描述-16" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定单向链表的头指针和一个节点指针，定义一个函数在O(1)时间内删除该节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">public class ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    ListNode next = null;</span><br><span class="line"></span><br><span class="line">    ListNode(int val) &#123;</span><br><span class="line">        this.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<h3 id="题解-16"><a href="#题解-16" class="headerlink" title="题解"></a>题解</h3><p>对于一个链表：1-&gt;2-&gt;3-&gt;4-&gt;5，如果要删除节点4，</p>
<p>首先想到的思路是找到节点4前面的节点（此处也就是节点3），将3的下一个节点重新设置为要删除的节点的下一个节点（此处也就是5），此时链表就变为了1-&gt;2-&gt;3-&gt;5。但由于链表是单向链表，不能从要删除的节点直接得到上一个节点，因此只能从头开始顺序查找，时间复杂度就为O(n)了。</p>
<p>另一种思路则是将要删除的节点的下一个节点的值赋值给要删除的节点，再将要删除的节点的下一个节点重新设置为下下个节点：<br>1-&gt;2-&gt;3-&gt;5-&gt;5<br>1-&gt;2-&gt;3-&gt;5<br>此时，时间复杂度就为O(1)了。</p>
<p>但如果要删除的节点为尾节点，则没有下一个节点，此种情况依然要使用顺序查找的方式删除节点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteNode</span><span class="params">(ListNode head, ListNode tobeDelete)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(head == <span class="keyword">null</span> || tobeDelete == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//要删除的节点不是尾节点</span></span><br><span class="line">		<span class="keyword">if</span>(tobeDelete.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">			tobeDelete.val = tobeDelete.next.val;</span><br><span class="line">			tobeDelete.next = tobeDelete.next.next;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">//要删除的节点是尾节点</span></span><br><span class="line">			ListNode node = head;</span><br><span class="line">			<span class="keyword">if</span>(node == tobeDelete) &#123;</span><br><span class="line">				<span class="comment">//如果链表中只有要删除的这一个节点</span></span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">while</span>(node.next != tobeDelete) &#123;</span><br><span class="line">				node = node.next;</span><br><span class="line">			&#125;</span><br><span class="line">			node.next = <span class="keyword">null</span>;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> head;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="18-2-删除链表中重复的结点"><a href="#18-2-删除链表中重复的结点" class="headerlink" title="18.2 删除链表中重复的结点"></a>18.2 删除链表中重复的结点</h2><h3 id="题目描述-17"><a href="#题目描述-17" class="headerlink" title="题目描述"></a>题目描述</h3><p>在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">public class ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    ListNode next = null;</span><br><span class="line"></span><br><span class="line">    ListNode(int val) &#123;</span><br><span class="line">        this.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<h3 id="题解-17"><a href="#题解-17" class="headerlink" title="题解"></a>题解</h3><p>如果当前节点的值与下一个节点的值相同，那么它们就是重复的节点，都可以被删除。为了保证删除之后的链表仍然是相连的，我们要把当前节点的前一个节点和后面值比当前节点的值大的节点相连。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplication</span><span class="params">(ListNode pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(pHead == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//如果链表中只存在一个节点，则不存在重复的节点</span></span><br><span class="line">		<span class="keyword">if</span>(pHead.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> pHead;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		ListNode preNode = <span class="keyword">null</span>;</span><br><span class="line">		ListNode node = pHead;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">while</span>(node != <span class="keyword">null</span>) &#123;</span><br><span class="line">			ListNode nextNode = node.next;</span><br><span class="line">			<span class="keyword">if</span>(nextNode != <span class="keyword">null</span> &amp;&amp; !(nextNode.val == node.val)) &#123;</span><br><span class="line">				<span class="comment">//当前节点与下一个节点不同</span></span><br><span class="line">				preNode = node;</span><br><span class="line">				node = nextNode;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">if</span>(node.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">//当前节点与下一个相同</span></span><br><span class="line">				<span class="keyword">int</span> value = node.val;</span><br><span class="line">				ListNode toBeDel = node;</span><br><span class="line">				<span class="keyword">while</span>(toBeDel != <span class="keyword">null</span> &amp;&amp; toBeDel.val == value) &#123;</span><br><span class="line">					nextNode = toBeDel.next;</span><br><span class="line">					toBeDel = nextNode;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span>(preNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">					pHead = nextNode;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					preNode.next = nextNode;</span><br><span class="line">				&#125;</span><br><span class="line">				node = nextNode;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> pHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="19-正则表达式匹配"><a href="#19-正则表达式匹配" class="headerlink" title="19 正则表达式匹配"></a>19 正则表达式匹配</h2><h3 id="题目描述-18"><a href="#题目描述-18" class="headerlink" title="题目描述"></a>题目描述</h3><p>请实现一个函数用来匹配包括’.’和’<em>‘的正则表达式。模式中的字符’.’表示任意一个字符，而’</em>‘表示它前面的字符可以出现任意次（包含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab<em>ac</em>a”匹配，但是与”aa.a”和”ab*a”均不匹配.</p>
<h3 id="题解-18"><a href="#题解-18" class="headerlink" title="题解"></a>题解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(<span class="keyword">char</span>[] str, <span class="keyword">char</span>[] pattern)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str == <span class="keyword">null</span> || pattern == <span class="keyword">null</span>) &#123;</span><br><span class="line">        	<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> strIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> patternIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> matchCore(str, pattern, strIndex, patternIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matchCore</span><span class="params">(<span class="keyword">char</span>[] str, <span class="keyword">char</span>[] pattern, <span class="keyword">int</span> strIndex, <span class="keyword">int</span> patternIndex)</span> </span>&#123;</span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">//字符串与模式完全匹配</span></span><br><span class="line">    	<span class="keyword">if</span>(strIndex == str.length &amp;&amp; patternIndex == pattern.length) &#123;</span><br><span class="line">    		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">//字符串未到达末尾，而模式已到达末尾，则匹配失败</span></span><br><span class="line">    	<span class="keyword">if</span>(strIndex != str.length &amp;&amp; patternIndex == pattern.length) &#123;</span><br><span class="line">    		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    	</span><br><span class="line">    	<span class="keyword">if</span>(patternIndex + <span class="number">1</span> &lt; pattern.length &amp;&amp; pattern[patternIndex + <span class="number">1</span>] == <span class="string">'*'</span>) &#123;</span><br><span class="line">    		<span class="comment">//模式的第二个字符为*</span></span><br><span class="line">    		<span class="keyword">if</span>(strIndex &lt; str.length &amp;&amp; str[strIndex] == pattern[patternIndex] || strIndex &lt; str.length &amp;&amp; pattern[patternIndex] == <span class="string">'.'</span>) &#123;</span><br><span class="line">    			<span class="comment">//*前的字符与字符串中的字符相等时</span></span><br><span class="line">    			<span class="comment">//可能的情况：匹配0位，模式向后移动两位跳过*；匹配一位，模式向后移动两位跳过*；匹配一位，模式不移动，下次继续匹配。</span></span><br><span class="line">    			<span class="keyword">return</span> matchCore(str, pattern, strIndex, patternIndex+<span class="number">2</span>) || matchCore(str, pattern, strIndex+<span class="number">1</span>, patternIndex+<span class="number">2</span>)</span><br><span class="line">    					|| matchCore(str, pattern, strIndex+<span class="number">1</span>, patternIndex);</span><br><span class="line">    		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    			<span class="comment">//*前的字符与字符串中的字符不相等时，匹配0位，跳过*</span></span><br><span class="line">    			<span class="keyword">return</span> matchCore(str, pattern, strIndex, patternIndex+<span class="number">2</span>);</span><br><span class="line">    		&#125;</span><br><span class="line">    		</span><br><span class="line">    	&#125; </span><br><span class="line">    	</span><br><span class="line">    	<span class="keyword">if</span>(pattern[patternIndex] == <span class="string">'.'</span> &amp;&amp; strIndex &lt; str.length || strIndex &lt; str.length &amp;&amp; pattern[patternIndex] == str[strIndex]) &#123;</span><br><span class="line">    		<span class="comment">//模式的第二个字符不为*</span></span><br><span class="line">    		<span class="keyword">if</span>(str[strIndex] == pattern[patternIndex] || pattern[patternIndex] == <span class="string">'.'</span>) &#123;</span><br><span class="line">    			<span class="comment">//如果字符相匹配,则接续操作</span></span><br><span class="line">    			<span class="keyword">return</span> matchCore(str, pattern, strIndex+<span class="number">1</span>, patternIndex+<span class="number">1</span>);</span><br><span class="line">    		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    			<span class="comment">//字符不匹配，直接返回false</span></span><br><span class="line">    			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    	</span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="20-表示数值的字符串"><a href="#20-表示数值的字符串" class="headerlink" title="20 表示数值的字符串"></a>20 表示数值的字符串</h2><h3 id="题目描述-19"><a href="#题目描述-19" class="headerlink" title="题目描述"></a>题目描述</h3><p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”,”5e2”,”-123”,”3.1416”和”-1E-16”都表示数值。 但是”12e”,”1a3.14”,”1.2.3”,”+-5”和”12e+4.3”都不是。</p>
<h3 id="题解-19"><a href="#题解-19" class="headerlink" title="题解"></a>题解</h3><p>表示数值的字符串遵循模式：A[.[b]][e|EC]或者.B[e|EC]。A和C都可以带有符号’+’或’-‘，B则不行，且A、B、C都必须为整数。因此，可以根据模式的顺序去依次匹配A、B、C。如果字符串中包含’.’，则’.’左右至少要有一方有数字，而如果字符串中包含’e’或’E’，则’e’或’E’两方都必须要有数字，且右方必须为整数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNumeric</span><span class="params">(<span class="keyword">char</span>[] str)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">boolean</span> flag;</span><br><span class="line">    	</span><br><span class="line">    	<span class="keyword">if</span>(str == <span class="keyword">null</span>)</span><br><span class="line">    		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    	</span><br><span class="line">    	flag = scanInteger(str);</span><br><span class="line">    	</span><br><span class="line">    	<span class="keyword">if</span>(index &lt; str.length &amp;&amp; str[index] == <span class="string">'.'</span>) &#123;</span><br><span class="line">    		index++;</span><br><span class="line">    		flag = scanUnsignedInteger(str) || flag;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">if</span>(index &lt; str.length &amp;&amp; (str[index] == <span class="string">'e'</span> || str[index] == <span class="string">'E'</span>)) &#123;</span><br><span class="line">    		index++;</span><br><span class="line">    		flag = scanInteger(str) &amp;&amp; flag;</span><br><span class="line">    	&#125;</span><br><span class="line">    	</span><br><span class="line">        <span class="keyword">return</span> flag &amp;&amp; (index == str.length);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">scanUnsignedInteger</span><span class="params">(<span class="keyword">char</span>[] str)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">int</span> before = index;</span><br><span class="line">    	<span class="keyword">while</span>(index &lt; str.length &amp;&amp; str[index] &gt;= <span class="string">'0'</span> &amp;&amp; str[index] &lt;= <span class="string">'9'</span>) &#123;</span><br><span class="line">    		index++;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span> index &gt; before;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">scanInteger</span><span class="params">(<span class="keyword">char</span>[] str)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(index &lt; str.length &amp;&amp; (str[index] == <span class="string">'+'</span> || str[index] == <span class="string">'-'</span>))</span><br><span class="line">    		index++;</span><br><span class="line">    	<span class="keyword">return</span> scanUnsignedInteger(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="21-调整数组顺序使奇数位于偶数前面"><a href="#21-调整数组顺序使奇数位于偶数前面" class="headerlink" title="21 调整数组顺序使奇数位于偶数前面"></a>21 调整数组顺序使奇数位于偶数前面</h2><h3 id="题目描述-20"><a href="#题目描述-20" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分（拓展：并保证奇数和奇数，偶数和偶数之间的相对位置不变）。</p>
<h3 id="题解-20"><a href="#题解-20" class="headerlink" title="题解"></a>题解</h3><h4 id="基本解法"><a href="#基本解法" class="headerlink" title="基本解法"></a>基本解法</h4><p>一前一后扫描数组，若发现有偶数在前，奇数在后，则交换它们两的位置。此算法的时间复杂度为O(n)，但是算法是不稳定的，也就是没法保证奇数和奇数，偶数和偶数之间的相对位置不变。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reOrderArray</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">int</span> head = <span class="number">0</span>;</span><br><span class="line">    	<span class="keyword">int</span> tail = array.length - <span class="number">1</span>;</span><br><span class="line">    	<span class="keyword">while</span>(head &lt; tail) &#123;</span><br><span class="line">    		<span class="keyword">while</span>(head &lt; array.length &amp;&amp; array[head] % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">    			<span class="comment">//正向遍历不为偶数的时候</span></span><br><span class="line">    			head++;</span><br><span class="line">    		&#125;</span><br><span class="line">    		<span class="keyword">while</span>(tail &gt;= <span class="number">0</span> &amp;&amp; array[tail] % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">    			<span class="comment">//反向遍历不为奇数的时候</span></span><br><span class="line">    			tail--;</span><br><span class="line">    		&#125;</span><br><span class="line">    		<span class="keyword">if</span>(head &lt; tail) &#123;</span><br><span class="line">    			<span class="keyword">int</span> temp = array[head];</span><br><span class="line">    			array[head] = array[tail];</span><br><span class="line">    			array[tail] = temp;</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="拓展解法"><a href="#拓展解法" class="headerlink" title="拓展解法"></a>拓展解法</h4><p>要保证奇数和奇数，偶数和偶数之间的相对位置不变，则需要使用一个辅助数组，首先计算出奇数的个数，以此作为将偶数插入辅助数组的起始坐标。然后遍历原数组，将奇数放置于辅助数组的奇数起始坐标（也就是0），将偶数放置于辅助数组的偶数起始坐标，最后再将调整完毕的辅助数组中的元素依次放回原数组。此算法的时间复杂度为O(n)，空间复杂度为O(n)，相当于以空间换时间。另一种思路是可以使用插入排序的思想，在此不再阐述。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reOrderArray</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] copy = <span class="keyword">new</span> <span class="keyword">int</span>[array.length];</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        	<span class="comment">//统计奇数个数</span></span><br><span class="line">        	<span class="keyword">if</span>(array[i] % <span class="number">2</span> != <span class="number">0</span>) count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> odd = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> even = count;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(index &lt; array.length) &#123;</span><br><span class="line">        	<span class="keyword">if</span>(array[index] % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">        		<span class="comment">//如果是奇数</span></span><br><span class="line">        		copy[odd] = array[index];</span><br><span class="line">        		odd++;</span><br><span class="line">        	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        		<span class="comment">//如果是偶数</span></span><br><span class="line">        		copy[even] = array[index];</span><br><span class="line">        		even++;</span><br><span class="line">        	&#125;</span><br><span class="line">        	index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        	array[i] = copy[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="22-链表中倒数第K个节点"><a href="#22-链表中倒数第K个节点" class="headerlink" title="22 链表中倒数第K个节点"></a>22 链表中倒数第K个节点</h2><h3 id="题目描述-21"><a href="#题目描述-21" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个链表，输出该链表中倒数第k个结点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">public class ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    ListNode next = null;</span><br><span class="line"></span><br><span class="line">    ListNode(int val) &#123;</span><br><span class="line">        this.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;*/</span><br></pre></td></tr></table></figure>
<h3 id="题解-21"><a href="#题解-21" class="headerlink" title="题解"></a>题解</h3><p>传统的思路是先遍历一遍链表，计算出节点数n，则倒数第k个节点就是从头开始的第n-k+1个节点。但此种做法要遍历链表两边，效率不高。</p>
<p>另一种思路是定义两个指针，让两个指针之间的距离保持在k-1，则当第一个指针到达链表的尾节点时，第二个指针则指向倒数第k个节点。这种实现只需要遍历链表一次即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">FindKthToTail</span><span class="params">(ListNode head,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || k &lt;= <span class="number">0</span>)</span><br><span class="line">    		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    	</span><br><span class="line">    	ListNode node1 = head;</span><br><span class="line">    	ListNode node2 = head;</span><br><span class="line">    	</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k-<span class="number">1</span>; i++) &#123;</span><br><span class="line">    		<span class="keyword">if</span>(node1.next == <span class="keyword">null</span>)</span><br><span class="line">    			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    		node1 = node1.next;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">while</span>(node1.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">    		node1 = node1.next;</span><br><span class="line">    		node2 = node2.next;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span> node2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="23-链表中环的入口节点"><a href="#23-链表中环的入口节点" class="headerlink" title="23 链表中环的入口节点"></a>23 链表中环的入口节点</h2><h3 id="题目描述-22"><a href="#题目描述-22" class="headerlink" title="题目描述"></a>题目描述</h3><p>给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">public class ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    ListNode next = null;</span><br><span class="line"></span><br><span class="line">    ListNode(int val) &#123;</span><br><span class="line">        this.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;*/</span><br></pre></td></tr></table></figure>
<h3 id="题解-22"><a href="#题解-22" class="headerlink" title="题解"></a>题解</h3><p>要找到链表中环的入口节点，整体思路与上一题类似。例如，如果环中有4个节点，则第二个指针要比第一个指针先走四步，然后同时向前走，当两个指针相遇时，所指向的节点就是入口节点。</p>
<p>根据此思路，要解决的问题是：如何计算环的节点数？这里可以先使用一快一慢两个指针，得到相遇时的节点（若第一个指针走到了null，说明链表中没有环，返回null），此节点必然在环内，然后从此节点开始绕环一圈，每走一步计数器加一，当回到原点时便得到了环的节点数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">EntryNodeOfLoop</span><span class="params">(ListNode head)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)</span><br><span class="line">    		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        ListNode meetingNode = MeetingNode(head);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(meetingNode == <span class="keyword">null</span>)</span><br><span class="line">        	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        			</span><br><span class="line">        ListNode node1 = head;</span><br><span class="line">        ListNode node2 = head;</span><br><span class="line">        ListNode node = meetingNode.next;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(node != meetingNode) &#123;</span><br><span class="line">        	count++;</span><br><span class="line">        	node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        	node1 = node1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(node1 != node2) &#123;</span><br><span class="line">        	node1 = node1.next;</span><br><span class="line">        	node2 = node2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">MeetingNode</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    	ListNode node1 = head;</span><br><span class="line">    	ListNode node2 = head;</span><br><span class="line">    	</span><br><span class="line">    	<span class="keyword">while</span>(node1.next != <span class="keyword">null</span> &amp;&amp; node1.next.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">    		node1 = node1.next.next;</span><br><span class="line">    		node2 = node2.next;</span><br><span class="line">    		<span class="keyword">if</span>(node1 == node2)</span><br><span class="line">    			<span class="keyword">return</span> node1;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="24-反转链表"><a href="#24-反转链表" class="headerlink" title="24 反转链表"></a>24 反转链表</h2><h3 id="题目描述-23"><a href="#题目描述-23" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个链表，反转链表后，输出新链表的表头。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">public class ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    ListNode next = null;</span><br><span class="line"></span><br><span class="line">    ListNode(int val) &#123;</span><br><span class="line">        this.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;*/</span><br></pre></td></tr></table></figure>
<h3 id="题解-23"><a href="#题解-23" class="headerlink" title="题解"></a>题解</h3><p>定义三个指针分别指向前一个节点，当前节点和后一个节点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">ReverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(head == <span class="keyword">null</span>)</span><br><span class="line">    		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    	</span><br><span class="line">    	ListNode preNode = <span class="keyword">null</span>;</span><br><span class="line">    	ListNode currNode = head;</span><br><span class="line">    	ListNode nextNode = head.next;</span><br><span class="line">    	ListNode reNode = <span class="keyword">null</span>;</span><br><span class="line">    	</span><br><span class="line">    	<span class="keyword">while</span>(currNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">    		<span class="keyword">if</span>(nextNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">    			reNode = currNode;</span><br><span class="line">    			currNode.next = preNode;</span><br><span class="line">    			<span class="keyword">break</span>;</span><br><span class="line">    		&#125;</span><br><span class="line">    		currNode.next = preNode;</span><br><span class="line">    		preNode = currNode;</span><br><span class="line">    		currNode = nextNode;</span><br><span class="line">    		nextNode  = currNode.next;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span> reNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="25-合并两个排序的链表"><a href="#25-合并两个排序的链表" class="headerlink" title="25 合并两个排序的链表"></a>25 合并两个排序的链表</h2><h3 id="题目描述-24"><a href="#题目描述-24" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">public class ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    ListNode next = null;</span><br><span class="line"></span><br><span class="line">    ListNode(int val) &#123;</span><br><span class="line">        this.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;*/</span><br></pre></td></tr></table></figure>
<h3 id="题解-24"><a href="#题解-24" class="headerlink" title="题解"></a>题解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">Merge</span><span class="params">(ListNode list1,ListNode list2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(list1 == <span class="keyword">null</span>)</span><br><span class="line">        	<span class="keyword">return</span> list2;</span><br><span class="line">        <span class="keyword">if</span>(list2 == <span class="keyword">null</span>)</span><br><span class="line">        	<span class="keyword">return</span> list1;</span><br><span class="line">        </span><br><span class="line">        ListNode head = <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(list1.val &lt; list2.val) &#123;</span><br><span class="line">        	head = list1;</span><br><span class="line">        	head.next = Merge(list1.next, list2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">        	head = list2;</span><br><span class="line">        	head.next = Merge(list1, list2.next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="26-树的子结构"><a href="#26-树的子结构" class="headerlink" title="26 树的子结构"></a>26 树的子结构</h2><h3 id="题目描述-25"><a href="#题目描述-25" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">public class TreeNode &#123;</span><br><span class="line">    int val = 0;</span><br><span class="line">    TreeNode left = null;</span><br><span class="line">    TreeNode right = null;</span><br><span class="line"></span><br><span class="line">    public TreeNode(int val) &#123;</span><br><span class="line">        this.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<h3 id="题解-25"><a href="#题解-25" class="headerlink" title="题解"></a>题解</h3><p>第一步是在树A中查找与根节点的值一样的节点，第二步是判断以此节点为根节点的子树是不是和树B具有相同的结构。此题要特别注意由于计算机表示小数含有误差，不能直接使用==进行double类型的等值判断，而是判断两个小数的差的绝对值是否小于某一个可忽略的数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">HasSubtree</span><span class="params">(TreeNode root1,TreeNode root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root1 != <span class="keyword">null</span> &amp;&amp; root2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        	<span class="keyword">if</span>(Equal(root1.val, root2.val))</span><br><span class="line">        		result = DoesTree1HaveTree2(root1, root2);</span><br><span class="line">        	<span class="keyword">if</span>(!result)</span><br><span class="line">        		result = HasSubtree(root1.left, root2);</span><br><span class="line">        	<span class="keyword">if</span>(!result)</span><br><span class="line">        		result = HasSubtree(root1.right, root2);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">DoesTree1HaveTree2</span><span class="params">(TreeNode root1, TreeNode root2)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(root2 == <span class="keyword">null</span>)</span><br><span class="line">    		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    	<span class="keyword">if</span>(root1 == <span class="keyword">null</span>)</span><br><span class="line">    		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    	</span><br><span class="line">    	<span class="keyword">if</span>(!Equal(root1.val, root2.val))</span><br><span class="line">    		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    	</span><br><span class="line">    	<span class="keyword">return</span> DoesTree1HaveTree2(root1.left, root2.left) &amp;&amp; DoesTree1HaveTree2(root1.right, root2.right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Equal</span><span class="params">(<span class="keyword">double</span> num1, <span class="keyword">double</span> num2)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(num1- num2 &gt; -<span class="number">0.0000001</span> &amp;&amp; num1 - num2 &lt; <span class="number">0.0000001</span>)</span><br><span class="line">    		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="27-二叉树的镜像"><a href="#27-二叉树的镜像" class="headerlink" title="27 二叉树的镜像"></a>27 二叉树的镜像</h2><h3 id="题目描述-26"><a href="#题目描述-26" class="headerlink" title="题目描述"></a>题目描述</h3><p>操作给定的二叉树，将其变换为源二叉树的镜像。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">二叉树的镜像定义：</span><br><span class="line"></span><br><span class="line">	源二叉树 </span><br><span class="line">    	    8</span><br><span class="line">    	   /  \</span><br><span class="line">    	  6   10</span><br><span class="line">    	 / \  / \</span><br><span class="line">    	5  7 9 11</span><br><span class="line">	</span><br><span class="line">    	镜像二叉树</span><br><span class="line">    	    8</span><br><span class="line">    	   /  \</span><br><span class="line">    	  10   6</span><br><span class="line">    	 / \  / \</span><br><span class="line">    	11 9 7  5</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">public class TreeNode &#123;</span><br><span class="line">    int val = 0;</span><br><span class="line">    TreeNode left = null;</span><br><span class="line">    TreeNode right = null;</span><br><span class="line"></span><br><span class="line">    public TreeNode(int val) &#123;</span><br><span class="line">        this.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<h3 id="题解-26"><a href="#题解-26" class="headerlink" title="题解"></a>题解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Mirror</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">    		<span class="keyword">return</span>;</span><br><span class="line">    	<span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)</span><br><span class="line">    		<span class="keyword">return</span>;</span><br><span class="line">    	</span><br><span class="line">    	TreeNode temp;</span><br><span class="line">    	temp = root.left;</span><br><span class="line">    	root.left = root.right;</span><br><span class="line">    	root.right = temp;</span><br><span class="line">    	</span><br><span class="line">    	<span class="keyword">if</span>(root.left != <span class="keyword">null</span>)</span><br><span class="line">    		Mirror(root.left);</span><br><span class="line">    	<span class="keyword">if</span>(root.right != <span class="keyword">null</span>)</span><br><span class="line">    		Mirror(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="28-对称的二叉树"><a href="#28-对称的二叉树" class="headerlink" title="28 对称的二叉树"></a>28 对称的二叉树</h2><h3 id="题目描述-27"><a href="#题目描述-27" class="headerlink" title="题目描述"></a>题目描述</h3><p>请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  对称的二叉树 </span><br><span class="line">    8</span><br><span class="line">   /  \</span><br><span class="line">  6    6</span><br><span class="line"> / \  / \</span><br><span class="line">5  7 7   5</span><br><span class="line">	</span><br><span class="line"> 非对称的二叉树</span><br><span class="line">    8</span><br><span class="line">   /  \</span><br><span class="line">  6    9</span><br><span class="line"> / \  / \</span><br><span class="line">5  7 7   5</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">public class TreeNode &#123;</span><br><span class="line">    int val = 0;</span><br><span class="line">    TreeNode left = null;</span><br><span class="line">    TreeNode right = null;</span><br><span class="line"></span><br><span class="line">    public TreeNode(int val) &#123;</span><br><span class="line">        this.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<h3 id="题解-27"><a href="#题解-27" class="headerlink" title="题解"></a>题解</h3><p>对于上图的非对称的二叉树，可以发现前序序列为{8, 6, 5, 7, 6, 7, 5}，对称前序序列为{8, 9, 5, 7, 6, 7, 5}。<br>而对于对称的二叉树，前序序列与对称前序序列都为{8, 6, 5, 7, 6, 7, 5}。<br>因此，通过比较二叉树的前序序列和对称前序序列即可判断出二叉树是否对称。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isSymmetrical</span><span class="params">(TreeNode pRoot)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isSymmetrical(pRoot, pRoot);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isSymmetrical</span><span class="params">(TreeNode pRoot1, TreeNode pRoot2)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(pRoot1 == <span class="keyword">null</span> &amp;&amp; pRoot2 == <span class="keyword">null</span>)</span><br><span class="line">    		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    	<span class="keyword">if</span>(pRoot1 == <span class="keyword">null</span> || pRoot2 == <span class="keyword">null</span>)</span><br><span class="line">    		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    	<span class="keyword">if</span>(pRoot1.val != pRoot2.val)</span><br><span class="line">    		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    	<span class="keyword">return</span> isSymmetrical(pRoot1.left, pRoot2.right) &amp;&amp; isSymmetrical(pRoot1.right, pRoot2.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="29-顺时针打印矩阵"><a href="#29-顺时针打印矩阵" class="headerlink" title="29 顺时针打印矩阵"></a>29 顺时针打印矩阵</h2><h3 id="题目描述-28"><a href="#题目描述-28" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.</p>
<h3 id="题解-28"><a href="#题解-28" class="headerlink" title="题解"></a>题解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printMatrix</span><span class="params">(<span class="keyword">int</span> [][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix == <span class="keyword">null</span>)</span><br><span class="line">        	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> columns = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> rows = matrix.length;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(columns == <span class="number">0</span> || rows == <span class="number">0</span>)</span><br><span class="line">        	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ArrayList&lt;Integer&gt; arr = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(columns &gt; start*<span class="number">2</span> &amp;&amp; rows &gt; start*<span class="number">2</span>) &#123;</span><br><span class="line">        	arr.addAll(PrintMatrixInCircle(matrix, columns, rows, start));</span><br><span class="line">        	start++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">PrintMatrixInCircle</span><span class="params">(<span class="keyword">int</span> [][]matrix, <span class="keyword">int</span> columns, <span class="keyword">int</span> rows, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">    	ArrayList&lt;Integer&gt; arr = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    	</span><br><span class="line">    	<span class="keyword">int</span> endX = columns - <span class="number">1</span> - start;</span><br><span class="line">    	<span class="keyword">int</span> endY = rows - <span class="number">1</span> - start;</span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">//从左到右打印一行</span></span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt;= endX; ++i) &#123;</span><br><span class="line">    		<span class="keyword">int</span> number = matrix[start][i];</span><br><span class="line">    		arr.add(number);</span><br><span class="line">    	&#125;</span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">//从上到下打印一列</span></span><br><span class="line">    	<span class="keyword">if</span>(start &lt; endY) &#123;</span><br><span class="line">    		<span class="keyword">for</span>(<span class="keyword">int</span> i = start + <span class="number">1</span>; i &lt;= endY; ++i) &#123;</span><br><span class="line">    			<span class="keyword">int</span> number = matrix[i][endX];</span><br><span class="line">    			arr.add(number);</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">//从右到左打印一行</span></span><br><span class="line">    	<span class="keyword">if</span>(start &lt; endX &amp;&amp; start &lt; endY) &#123;</span><br><span class="line">    		<span class="keyword">for</span>(<span class="keyword">int</span> i = endX - <span class="number">1</span>; i &gt;= start; --i) &#123;</span><br><span class="line">    			<span class="keyword">int</span> number = matrix[endY][i];</span><br><span class="line">    			arr.add(number);</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">//从下到上打印一行</span></span><br><span class="line">    	<span class="keyword">if</span>(start &lt; endX &amp;&amp; start &lt; endY - <span class="number">1</span>) &#123;</span><br><span class="line">    		<span class="keyword">for</span>(<span class="keyword">int</span> i = endY - <span class="number">1</span>; i &gt;= start + <span class="number">1</span>; --i) &#123;</span><br><span class="line">    			<span class="keyword">int</span> number = matrix[i][start];</span><br><span class="line">    			arr.add(number);</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    	</span><br><span class="line">    	<span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="30-包含min函数的栈"><a href="#30-包含min函数的栈" class="headerlink" title="30 包含min函数的栈"></a>30 包含min函数的栈</h2><h3 id="题目描述-29"><a href="#题目描述-29" class="headerlink" title="题目描述"></a>题目描述</h3><p>定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。</p>
<h3 id="题解-29"><a href="#题解-29" class="headerlink" title="题解"></a>题解</h3><p>使用一个辅助栈。第一次压入的时候，把该元素同时也压入到辅助栈中。以后每次压入新元素的时候，如果新元素比辅助栈栈顶的元素小，就把新元素也压入到辅助栈中，否则，就把辅助栈栈顶的元素再次压入。这么做可以使辅助栈的每个元素对应着数据栈中该位置元素之前的最小元素，即每次从数据栈和辅助栈中弹出一个元素时，辅助栈的栈顶都保存着数据栈的最小元素。由此我们也可以发现，在辅助栈中，新元素的值要么比上一层的值小，要么等于上一层的值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Stack&lt;Integer&gt; data = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> Stack&lt;Integer&gt; dataHelper = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">    	data.push(node);</span><br><span class="line">    	<span class="keyword">if</span>(dataHelper.isEmpty()) &#123;</span><br><span class="line">    		dataHelper.push(node);</span><br><span class="line">    	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    		<span class="keyword">if</span>(node &lt; dataHelper.peek()) &#123;</span><br><span class="line">	        	dataHelper.push(node);</span><br><span class="line">	        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	        	dataHelper.push(dataHelper.peek());</span><br><span class="line">	        &#125;</span><br><span class="line">    	&#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        data.pop();</span><br><span class="line">        dataHelper.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dataHelper.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="31-栈的压入、弹出序列"><a href="#31-栈的压入、弹出序列" class="headerlink" title="31 栈的压入、弹出序列"></a>31 栈的压入、弹出序列</h2><h3 id="题目描述-30"><a href="#题目描述-30" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</p>
<h3 id="题解-30"><a href="#题解-30" class="headerlink" title="题解"></a>题解</h3><p>使用一个栈来模拟压入、弹出的操作，可以得到以下规律：</p>
<ul>
<li>如果下一个弹出的数字刚好是栈顶数字，直接弹出</li>
<li>否则，把压栈序列中还没有入栈的数字压入栈中，直到把下一个需要弹出的数字压入栈顶为止</li>
<li>压栈序列为空还没找到，离开循环</li>
<li>判断栈是否为空，为空则说明弹出序列匹配，否则，不匹配</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    Stack&lt;Integer&gt; helper = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsPopOrder</span><span class="params">(<span class="keyword">int</span> [] pushA,<span class="keyword">int</span> [] popA)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(pushA == <span class="keyword">null</span> || popA == <span class="keyword">null</span>)</span><br><span class="line">    		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    	</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; pushA.length; i++) &#123;</span><br><span class="line">    		helper.push(pushA[i]);</span><br><span class="line">    		</span><br><span class="line">    		<span class="keyword">while</span>(!helper.isEmpty() &amp;&amp; j &lt; popA.length &amp;&amp; helper.peek() == popA[j]) &#123;</span><br><span class="line">    			helper.pop();</span><br><span class="line">    			j++;</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    	</span><br><span class="line">    	<span class="keyword">return</span> helper.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="32-1-从上往下打印二叉树"><a href="#32-1-从上往下打印二叉树" class="headerlink" title="32.1 从上往下打印二叉树"></a>32.1 从上往下打印二叉树</h2><h3 id="题目描述-31"><a href="#题目描述-31" class="headerlink" title="题目描述"></a>题目描述</h3><p>从上往下打印出二叉树的每个节点，同层节点从左至右打印。</p>
<h3 id="题解-31"><a href="#题解-31" class="headerlink" title="题解"></a>题解</h3><p>每次打印一个节点的时候，如果该节点有子节点，就把子节点加入到队列中，然后再从队列头取首元素并打印，重复以上操作，直至队列为空。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">PrintFromTopToBottom</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">        	<span class="keyword">return</span> list;</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(queue.size() != <span class="number">0</span>) &#123;</span><br><span class="line">        	TreeNode node = queue.poll();</span><br><span class="line">        	list.add(node.val);</span><br><span class="line">        	<span class="keyword">if</span>(node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">        		queue.add(node.left);</span><br><span class="line">        	&#125;</span><br><span class="line">        	<span class="keyword">if</span>(node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        		queue.add(node.right);</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="32-2-把二叉树打印成多行"><a href="#32-2-把二叉树打印成多行" class="headerlink" title="32.2 把二叉树打印成多行"></a>32.2 把二叉树打印成多行</h2><h3 id="题目描述-32"><a href="#题目描述-32" class="headerlink" title="题目描述"></a>题目描述</h3><p>从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。</p>
<h3 id="题解-32"><a href="#题解-32" class="headerlink" title="题解"></a>题解</h3><p>用两个变量分别记录当前行还剩余的节点与下一行需要打印的节点。每打印完一行，都将下一行需要打印的节点数赋给当前剩余节点数，并将自身置0，以便重新开始新的一行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt; &gt; Print(TreeNode root) &#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; listAll = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">        	<span class="keyword">return</span> listAll;</span><br><span class="line">        <span class="keyword">int</span> toBePrinted = <span class="number">1</span>;	<span class="comment">//当前层中还没打印的节点数</span></span><br><span class="line">        <span class="keyword">int</span> nextLevel = <span class="number">0</span>;	<span class="comment">//下一层的节点数</span></span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(queue.size() != <span class="number">0</span>) &#123;</span><br><span class="line">        	TreeNode node = queue.poll();</span><br><span class="line">        	list.add(node.val);</span><br><span class="line">        	<span class="keyword">if</span>(node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">        		queue.add(node.left);</span><br><span class="line">        		nextLevel++;</span><br><span class="line">        	&#125;</span><br><span class="line">        	<span class="keyword">if</span>(node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        		queue.add(node.right);</span><br><span class="line">        		nextLevel++;</span><br><span class="line">        	&#125;</span><br><span class="line">        	toBePrinted--;</span><br><span class="line">        	<span class="keyword">if</span>(toBePrinted == <span class="number">0</span>) &#123;</span><br><span class="line">                listAll.add(list);</span><br><span class="line">                list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        		toBePrinted = nextLevel;</span><br><span class="line">        		nextLevel = <span class="number">0</span>;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> listAll;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="32-3-按之字形顺序打印二叉树"><a href="#32-3-按之字形顺序打印二叉树" class="headerlink" title="32.3 按之字形顺序打印二叉树"></a>32.3 按之字形顺序打印二叉树</h2><h3 id="题目描述-33"><a href="#题目描述-33" class="headerlink" title="题目描述"></a>题目描述</h3><p>请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。</p>
<h3 id="题解-33"><a href="#题解-33" class="headerlink" title="题解"></a>题解</h3><p>如果当前节点在奇数层，则将子节点以从左往右的顺序入栈；如果当前节点在偶数层，则将子节点以从右往左的顺序入栈。更简单地说：子节点入栈的方向与当前层节点弹出的方向一致。</p>
<p>在下面的算法中，用一个Stack数组保存当前层的栈与下一层的栈，用1和0表示奇数层和偶数层。当前层栈的节点弹出时，下一层栈的节点压入。如果当前层栈为空，则说明该行已经打印完成，将current与next置换（奇偶置换）后开始新的一行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt; &gt; Print(TreeNode root) &#123;</span><br><span class="line">    	    <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">    		<span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">   	    Stack&lt;TreeNode&gt;[] stack = <span class="keyword">new</span> Stack[<span class="number">2</span>];</span><br><span class="line">    	    stack[<span class="number">0</span>] = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">    	    stack[<span class="number">1</span>] = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">            ArrayList&lt;ArrayList&lt;Integer&gt;&gt; listAll = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            	<span class="keyword">return</span> listAll;</span><br><span class="line">    		<span class="keyword">int</span> current = <span class="number">1</span>;	<span class="comment">//表示奇数层</span></span><br><span class="line">    		<span class="keyword">int</span> next = <span class="number">0</span>;		<span class="comment">//表示偶数层</span></span><br><span class="line">    		stack[current].push(root);</span><br><span class="line">    		<span class="keyword">while</span>(stack[current].size() != <span class="number">0</span> || stack[next].size() != <span class="number">0</span>) &#123;</span><br><span class="line">    			TreeNode node = stack[current].pop();</span><br><span class="line">    			</span><br><span class="line">    			list.add(node.val);</span><br><span class="line">    			</span><br><span class="line">    			<span class="keyword">if</span>(current == <span class="number">1</span>) &#123;</span><br><span class="line">    				<span class="comment">//如果在奇数层，则子节点从左往右入栈</span></span><br><span class="line">    				<span class="keyword">if</span>(node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">    					stack[next].push(node.left);</span><br><span class="line">    				&#125;</span><br><span class="line">    				<span class="keyword">if</span>(node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">    					stack[next].push(node.right);</span><br><span class="line">    				&#125;</span><br><span class="line">    			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    				<span class="comment">//如果在偶数层，则子节点从右往左入栈</span></span><br><span class="line">    				<span class="keyword">if</span>(node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">    					stack[next].push(node.right);</span><br><span class="line">    				&#125;</span><br><span class="line">    				<span class="keyword">if</span>(node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">    					stack[next].push(node.left);</span><br><span class="line">    				&#125;</span><br><span class="line">    			&#125;</span><br><span class="line">    			</span><br><span class="line">    			<span class="keyword">if</span>(stack[current].size() == <span class="number">0</span>) &#123;</span><br><span class="line">    				listAll.add(list);</span><br><span class="line">    				list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    				current = <span class="number">1</span> - current;</span><br><span class="line">    				next = <span class="number">1</span> - next;</span><br><span class="line">    			&#125;</span><br><span class="line">    		&#125;</span><br><span class="line">    		<span class="keyword">return</span> listAll;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="33-二叉搜索树的后序遍历序列"><a href="#33-二叉搜索树的后序遍历序列" class="headerlink" title="33 二叉搜索树的后序遍历序列"></a>33 二叉搜索树的后序遍历序列</h2><h3 id="题目描述-34"><a href="#题目描述-34" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。</p>
<h3 id="题解-34"><a href="#题解-34" class="headerlink" title="题解"></a>题解</h3><p>先以以下二叉树为例，其输入数组为{5, 7, 6, 9, 11, 10, 8}。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    8</span><br><span class="line">   /  \</span><br><span class="line">  6    10</span><br><span class="line"> / \  / \</span><br><span class="line">5  7 9   11</span><br></pre></td></tr></table></figure>
<p>我们可以发现，数组的最后一个数字8就是二叉树的根节点，然后从数组开始进行遍历，凡是比8小的都属于根节点的左子树，其余的就是根节点的右子树，即{5, 7, 6, /9, 11, 10,/ 8}。我们在看看根节点的左子树，同样最后一个数字6是左子树的根节点，而5、7分别属于左子树根节点的左右子树。</p>
<p>再看看另一个例子：{7, 4, 6, 5}，由以上分析的规律可以发现，5为二叉树的根节点，而7、4、6都比5大，说明此二叉树没有左子树，而在右子树{7, 4, 6}中，7比6大，说明7在根节点的右子树中，而4却又比6小，这有违二叉树的定义，说明此数组不属于任何一个二叉树。</p>
<p>因此，我们可以使用递归来解决这个问题，先找到二叉树的根节点，再基于此根节点将数组拆分成左右子树，然后对左右子树分别进行递归。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">VerifySquenceOfBST</span><span class="params">(<span class="keyword">int</span> [] sequence)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sequence == <span class="keyword">null</span> || sequence.length &lt;= <span class="number">0</span>)</span><br><span class="line">    		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    	<span class="keyword">return</span> VerifySquenceOfBST(sequence, <span class="number">0</span>, sequence.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">VerifySquenceOfBST</span><span class="params">(<span class="keyword">int</span> [] sequence, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(end-begin&lt;<span class="number">0</span>)</span><br><span class="line">    		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    	</span><br><span class="line">    	<span class="keyword">int</span> root = sequence[end];</span><br><span class="line">    	</span><br><span class="line">    	<span class="keyword">int</span> i = begin;</span><br><span class="line">    	<span class="keyword">for</span>(;i &lt; end; i++) &#123;</span><br><span class="line">    		<span class="keyword">if</span>(sequence[i] &gt; root)</span><br><span class="line">    			<span class="keyword">break</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    	</span><br><span class="line">    	<span class="keyword">int</span> j = i;</span><br><span class="line">    	<span class="keyword">for</span>(;j &lt; end; j++) &#123;</span><br><span class="line">    		<span class="keyword">if</span>(sequence[j] &lt; root)</span><br><span class="line">    			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    	</span><br><span class="line">    	<span class="keyword">boolean</span> left = <span class="keyword">true</span>;</span><br><span class="line">    	<span class="keyword">if</span>(i &gt; <span class="number">0</span>)</span><br><span class="line">    		left = VerifySquenceOfBST(sequence, begin, i-<span class="number">1</span>);</span><br><span class="line">    	</span><br><span class="line">    	<span class="keyword">boolean</span> right = <span class="keyword">true</span>;</span><br><span class="line">    	<span class="keyword">if</span>(i &lt; end)</span><br><span class="line">    		right = VerifySquenceOfBST(sequence, i, end - <span class="number">1</span>);</span><br><span class="line">    	</span><br><span class="line">        <span class="keyword">return</span> (right &amp;&amp; left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="34-二叉树中和为某一值的路径"><a href="#34-二叉树中和为某一值的路径" class="headerlink" title="34 二叉树中和为某一值的路径"></a>34 二叉树中和为某一值的路径</h2><h3 id="题目描述-35"><a href="#题目描述-35" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一颗二叉树的跟节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">public class TreeNode &#123;</span><br><span class="line">    int val = 0;</span><br><span class="line">    TreeNode left = null;</span><br><span class="line">    TreeNode right = null;</span><br><span class="line"></span><br><span class="line">    public TreeNode(int val) &#123;</span><br><span class="line">        this.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<h3 id="题解-35"><a href="#题解-35" class="headerlink" title="题解"></a>题解</h3><p>此题运用深度优先搜索的思想。从左开始向下深度遍历，遇到叶节点之后，判断其值是否等于target，如果相等则将此路径加入到所有路径的列表中。每次回退的时候，都要将路径最后一个节点删除。</p>
<p>此题需要注意，将某一路径加入到所有路径列表时，必须新建一个ArrayList，否则每次都是将对同一个对象的引用加入到listAll中，而java中通过引用是可以改变对象内部的属性的，所以每次对list进行remove操作都会影响到listAll中已加入的所有list，最后由于list会回退到根节点并把根节点remove掉，导致listAll的路径数目虽然正确，但每条路径列表都为空。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root,<span class="keyword">int</span> target) &#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; listAll = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">        	<span class="keyword">return</span> listAll;</span><br><span class="line">        findPath(listAll, list, root, target);</span><br><span class="line">        <span class="keyword">return</span> listAll;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findPath</span><span class="params">(ArrayList&lt;ArrayList&lt;Integer&gt;&gt; listAll, ArrayList&lt;Integer&gt; list, TreeNode root, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    	list.add(root.val);</span><br><span class="line">    	<span class="comment">//如果为叶节点</span></span><br><span class="line">    	<span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">    		<span class="keyword">if</span>(root.val == target) &#123;</span><br><span class="line">    			ArrayList&lt;Integer&gt; newList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    			newList.addAll(list);</span><br><span class="line">    			listAll.add(newList);</span><br><span class="line">    		&#125;</span><br><span class="line">    		list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">    		<span class="keyword">return</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">if</span>(root.left != <span class="keyword">null</span>)</span><br><span class="line">    		findPath(listAll, list, root.left, target-root.val);</span><br><span class="line">    	<span class="keyword">if</span>(root.right != <span class="keyword">null</span>)</span><br><span class="line">    		findPath(listAll, list, root.right, target-root.val);</span><br><span class="line">    	list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">    	<span class="keyword">return</span>;</span><br><span class="line">    		</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="35-复杂链表的复制"><a href="#35-复杂链表的复制" class="headerlink" title="35 复杂链表的复制"></a>35 复杂链表的复制</h2><h3 id="题目描述-36"><a href="#题目描述-36" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">public class RandomListNode &#123;</span><br><span class="line">    int label;</span><br><span class="line">    RandomListNode next = null;</span><br><span class="line">    RandomListNode random = null;</span><br><span class="line"></span><br><span class="line">    RandomListNode(int label) &#123;</span><br><span class="line">        this.label = label;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<h3 id="题解-36"><a href="#题解-36" class="headerlink" title="题解"></a>题解</h3><p>解决此题大体有以下两个步骤：</p>
<p>1、根据原始链表的每个节点创建对应的复制节点</p>
<p>2、设置复制出来的节点的random节点</p>
<p>此题的关键在于定位random节点，需保证算法的时间复杂度在O(n)。</p>
<h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><p>在第一步创建每个复制节点时，使用哈希表保存原节点与复制节点，之后设置random节点时，每当通过查找哈希表原节点的random节点便可以在O(1)的时间找到该复制节点应指向的random节点。此算法相当于以空间换时间，空间复杂度为O(n)。</p>
<p>这里需要注意，java中的map是不能直接使用iterator遍历的，因此需要先通过entrySet()方法获取set视图。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Map.Entry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> RandomListNode <span class="title">Clone</span><span class="params">(RandomListNode head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)</span><br><span class="line">        	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        HashMap&lt;RandomListNode, RandomListNode&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        RandomListNode cloneNodeHead = <span class="keyword">new</span> RandomListNode(head.label);</span><br><span class="line">        RandomListNode cloneNode = cloneNodeHead;</span><br><span class="line">        map.put(head, cloneNode);</span><br><span class="line">        <span class="keyword">while</span>(head.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        	RandomListNode nextNode = <span class="keyword">new</span> RandomListNode(head.next.label);</span><br><span class="line">        	cloneNode.next = nextNode;</span><br><span class="line">        	cloneNode = cloneNode.next;</span><br><span class="line">        	head = head.next;</span><br><span class="line">        	map.put(head, cloneNode);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Iterator&lt;Entry&lt;RandomListNode, RandomListNode&gt;&gt; it = map.entrySet().iterator();</span><br><span class="line">        <span class="keyword">while</span>(it.hasNext()) &#123;</span><br><span class="line">        	Entry&lt;RandomListNode, RandomListNode&gt; entry = it.next();</span><br><span class="line">        	<span class="comment">//时间复杂度为O(1)，相当于以空间换时间</span></span><br><span class="line">        	RandomListNode sib = map.get(entry.getKey().random);</span><br><span class="line">        	entry.getValue().random = sib;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> cloneNodeHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="更好的解法"><a href="#更好的解法" class="headerlink" title="更好的解法"></a>更好的解法</h4><p>思路：在旧链表中创建新链表-&gt;根据旧链表的random节点初始化新链表的random节点-&gt;把新链表从旧链表中拆分出来。</p>
<p>此算法的时间复杂度为O(n)，且不需要辅助空间。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> RandomListNode <span class="title">Clone</span><span class="params">(RandomListNode head)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(head == <span class="keyword">null</span>)</span><br><span class="line">    	    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    	CloneNodes(head);</span><br><span class="line">    	ConnectSiblingNodes(head);</span><br><span class="line">    	<span class="keyword">return</span> ReconnectNodes(head);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">CloneNodes</span><span class="params">(RandomListNode head)</span> </span>&#123;</span><br><span class="line">    	RandomListNode test = head;</span><br><span class="line">    	<span class="keyword">while</span>(head != <span class="keyword">null</span>) &#123;</span><br><span class="line">    		RandomListNode cloneNode = <span class="keyword">new</span> RandomListNode(head.label);</span><br><span class="line">    		RandomListNode next = head.next;</span><br><span class="line">    		head.next = cloneNode;</span><br><span class="line">    		cloneNode.next = next;</span><br><span class="line">    		head = next;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConnectSiblingNodes</span><span class="params">(RandomListNode head)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">while</span>(head != <span class="keyword">null</span>) &#123;</span><br><span class="line">    		RandomListNode cloneNode = head.next;</span><br><span class="line">    		<span class="keyword">if</span>(head.random != <span class="keyword">null</span>) &#123;</span><br><span class="line">    			cloneNode.random = head.random.next;</span><br><span class="line">    		&#125;</span><br><span class="line">    		head = head.next.next;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> RandomListNode <span class="title">ReconnectNodes</span><span class="params">(RandomListNode head)</span> </span>&#123;</span><br><span class="line">    	RandomListNode cloneNode = head.next;</span><br><span class="line">    	RandomListNode cloneNodeHead = cloneNode;</span><br><span class="line">    	</span><br><span class="line">    	<span class="keyword">while</span>(head != <span class="keyword">null</span>) &#123;</span><br><span class="line">    		RandomListNode next = head.next.next;</span><br><span class="line">    		RandomListNode cloneNext;</span><br><span class="line">    		<span class="comment">//防止在最后一个节点处报空指针异常</span></span><br><span class="line">    		<span class="keyword">if</span>(next == <span class="keyword">null</span>) &#123;</span><br><span class="line">    			cloneNext = <span class="keyword">null</span>;</span><br><span class="line">    		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    			cloneNext = cloneNode.next.next;</span><br><span class="line">    		&#125;</span><br><span class="line">    		head.next = next;</span><br><span class="line">    		cloneNode.next = cloneNext;</span><br><span class="line">    		head = next;</span><br><span class="line">    		cloneNode = cloneNext;</span><br><span class="line">    	&#125;</span><br><span class="line">    	</span><br><span class="line">    	<span class="keyword">return</span> cloneNodeHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="36-二叉搜索树与双向链表"><a href="#36-二叉搜索树与双向链表" class="headerlink" title="36 二叉搜索树与双向链表"></a>36 二叉搜索树与双向链表</h2><h3 id="题目描述-37"><a href="#题目描述-37" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">public class TreeNode &#123;</span><br><span class="line">    int val = 0;</span><br><span class="line">    TreeNode left = null;</span><br><span class="line">    TreeNode right = null;</span><br><span class="line"></span><br><span class="line">    public TreeNode(int val) &#123;</span><br><span class="line">        this.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<h3 id="题解-37"><a href="#题解-37" class="headerlink" title="题解"></a>题解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">Convert</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">    		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    	<span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)</span><br><span class="line">    		<span class="keyword">return</span> root;</span><br><span class="line">    	TreeNode left = Convert(root.left);</span><br><span class="line">    	TreeNode p = left;</span><br><span class="line">    	<span class="keyword">while</span>(p != <span class="keyword">null</span> &amp;&amp; p.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">    		p = p.right;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">if</span>(left != <span class="keyword">null</span>) &#123;</span><br><span class="line">    		root.left = p;</span><br><span class="line">    		p.right = root;</span><br><span class="line">    	&#125;</span><br><span class="line">    	TreeNode right = Convert(root.right);</span><br><span class="line">    	<span class="keyword">if</span>(right != <span class="keyword">null</span>) &#123;</span><br><span class="line">    		root.right = right;</span><br><span class="line">    		right.left = root;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span> left != <span class="keyword">null</span> ? left : root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="37-序列化二叉树"><a href="#37-序列化二叉树" class="headerlink" title="37 序列化二叉树"></a>37 序列化二叉树</h2><h3 id="题目描述-38"><a href="#题目描述-38" class="headerlink" title="题目描述"></a>题目描述</h3><p>请实现两个函数，分别用来序列化和反序列化二叉树</p>
<h3 id="题解-38"><a href="#题解-38" class="headerlink" title="题解"></a>题解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> index = -<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">  <span class="function">String <span class="title">Serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        StringBuilder str = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        	str.append(<span class="string">"$,"</span>);</span><br><span class="line">        	<span class="keyword">return</span> str.toString();</span><br><span class="line">        &#125;</span><br><span class="line">        str.append(root.val+<span class="string">","</span>);</span><br><span class="line">        str.append(Serialize(root.left));</span><br><span class="line">        str.append(Serialize(root.right));</span><br><span class="line">        <span class="keyword">return</span> str.toString();  </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">TreeNode <span class="title">Deserialize</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">       String[] newStr = str.split(<span class="string">","</span>);</span><br><span class="line">       index++;</span><br><span class="line">       <span class="keyword">if</span>(index &lt; str.length() &amp;&amp; !newStr[index].equals(<span class="string">"$"</span>)) &#123;</span><br><span class="line">    	   TreeNode root = <span class="keyword">new</span> TreeNode(Integer.valueOf(newStr[index]));</span><br><span class="line">    	   root.left = Deserialize(str);</span><br><span class="line">    	   root.right = Deserialize(str);</span><br><span class="line">    	   <span class="keyword">return</span> root;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="38-字符串的排列"><a href="#38-字符串的排列" class="headerlink" title="38 字符串的排列"></a>38 字符串的排列</h2><h3 id="题目描述-39"><a href="#题目描述-39" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。</p>
<h3 id="题解-39"><a href="#题解-39" class="headerlink" title="题解"></a>题解</h3><p>回溯法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;String&gt; <span class="title">Permutation</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    	ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(str == <span class="keyword">null</span> || str.length() == <span class="number">0</span>)</span><br><span class="line">        	<span class="keyword">return</span> list;</span><br><span class="line">        Permutation(str.toCharArray(), <span class="number">0</span>, list);</span><br><span class="line">        Collections.sort(list);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Permutation</span><span class="params">(<span class="keyword">char</span>[] c, <span class="keyword">int</span> i, ArrayList&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(i == c.length) &#123;</span><br><span class="line">    		String str = String.valueOf(c);</span><br><span class="line">    		<span class="keyword">if</span>(!list.contains(str))</span><br><span class="line">    			list.add(String.valueOf(c));</span><br><span class="line">    		<span class="keyword">return</span>;</span><br><span class="line">    	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    		<span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; c.length; j++) &#123;</span><br><span class="line">    			swap(c, i, j);</span><br><span class="line">    			Permutation(c, i+<span class="number">1</span>, list);</span><br><span class="line">    			swap(c, i, j);</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">char</span>[] c, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    	<span class="keyword">char</span> temp;</span><br><span class="line">    	temp = c[i];</span><br><span class="line">    	c[i] = c[j];</span><br><span class="line">    	c[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="39-数组中出现次数超过一半的数字"><a href="#39-数组中出现次数超过一半的数字" class="headerlink" title="39 数组中出现次数超过一半的数字"></a>39 数组中出现次数超过一半的数字</h2><h3 id="题目描述-40"><a href="#题目描述-40" class="headerlink" title="题目描述"></a>题目描述</h3><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。</p>
<h3 id="题解-40"><a href="#题解-40" class="headerlink" title="题解"></a>题解</h3><h4 id="基于辅助数组的解法"><a href="#基于辅助数组的解法" class="headerlink" title="基于辅助数组的解法"></a>基于辅助数组的解法</h4><p>此种解法利用了辅助数组，在辅助数组中以原始数组的值为索引存储该值出现的次数，一旦次数超过原始数组的一半，则跳出循环返回该值。该解法空间复杂度为O(n)，相当于以空间换时间，且由于数组的限制，事先必须要知道原始数组中值的范围，若要克服后者，可以使用其它数据结构。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(array == <span class="keyword">null</span> || array.length == <span class="number">0</span>) &#123;</span><br><span class="line">    		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">int</span> length = array.length;</span><br><span class="line">    	<span class="keyword">int</span>[] helper = <span class="keyword">new</span> <span class="keyword">int</span>[length+<span class="number">1</span>];</span><br><span class="line">    	<span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    	</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    		helper[array[i]]++;</span><br><span class="line">    		<span class="keyword">if</span>(helper[array[i]] &gt; length / <span class="number">2</span>) &#123;</span><br><span class="line">    			result = array[i];</span><br><span class="line">    			<span class="keyword">break</span>;</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    	</span><br><span class="line">    	<span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="多数投票算法"><a href="#多数投票算法" class="headerlink" title="多数投票算法"></a>多数投票算法</h4><p>多数投票算(摩尔投票算法)：定义一个结果变量和一个计数器，初始化的情况下计数器为0. 算法依次扫描序列中的元素，当处理某元素的时候，如果计数器为0，那么将该元素赋值给结果变量，然后将计数器设置为1，如果计数器不为0，那么将结果变量和该元素比较，如果相等，那么计数器加1，如果不等，那么计数器减1。处理之后，最后存储的结果变量就是这个数组中超过一半以上的元素。</p>
<p>需注意：如果一个元素的出现次数超过数组长度的一半，那么结果变量肯定为该元素，但结果变量元素的出现次数不一定超过数组长度的一半，因此需要进行第二次遍历确认。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(array == <span class="keyword">null</span> || array.length == <span class="number">0</span>) &#123;</span><br><span class="line">    		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    	</span><br><span class="line">    	<span class="keyword">int</span> result = array[<span class="number">0</span>];</span><br><span class="line">    	<span class="keyword">int</span> n = <span class="number">1</span>;</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">    		<span class="keyword">if</span>(n == <span class="number">0</span>) &#123;</span><br><span class="line">    			result = array[i];</span><br><span class="line">    			n = <span class="number">1</span>;</span><br><span class="line">    		&#125; </span><br><span class="line">    		<span class="keyword">else</span> <span class="keyword">if</span>(array[i] == result) </span><br><span class="line">    			n++;</span><br><span class="line">    		<span class="keyword">else</span></span><br><span class="line">    			n--;</span><br><span class="line">    	&#125;</span><br><span class="line">    	</span><br><span class="line">    	n = <span class="number">0</span>;</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">    		<span class="keyword">if</span>(array[i] == result) &#123;</span><br><span class="line">    			n++;</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    	</span><br><span class="line">    	<span class="keyword">if</span>(n &lt;= array.length / <span class="number">2</span>)</span><br><span class="line">    		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    	<span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="40-最小的k个数"><a href="#40-最小的k个数" class="headerlink" title="40 最小的k个数"></a>40 最小的k个数</h2><h3 id="题目描述-41"><a href="#题目描述-41" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。</p>
<h3 id="题解-41"><a href="#题解-41" class="headerlink" title="题解"></a>题解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">GetLeastNumbers_Solution</span><span class="params">(<span class="keyword">int</span> [] input, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(input == <span class="keyword">null</span> || input.length &lt;= <span class="number">0</span> || k &lt; <span class="number">1</span> || k &gt; input.length) &#123;</span><br><span class="line">        	<span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">        PriorityQueue&lt;Integer&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(k+<span class="number">1</span>, <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">        	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">        		<span class="keyword">return</span> o2 - o1;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; input.length; i++) &#123;</span><br><span class="line">        	heap.add(input[i]);</span><br><span class="line">        	<span class="keyword">if</span>(heap.size() &gt; k) &#123;</span><br><span class="line">        		heap.poll();</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(Integer i : heap) &#123;</span><br><span class="line">        	list.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="41-数据流中的中位数"><a href="#41-数据流中的中位数" class="headerlink" title="41 数据流中的中位数"></a>41 数据流中的中位数</h2><h3 id="题目描述-42"><a href="#题目描述-42" class="headerlink" title="题目描述"></a>题目描述</h3><p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。</p>
<h3 id="题解-42"><a href="#题解-42" class="headerlink" title="题解"></a>题解</h3><p>用最大堆与最小堆来实现，插入的时间复杂度为O(log(n))。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    PriorityQueue&lt;Integer&gt; max = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> o2.compareTo(o1);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">	</span><br><span class="line">	PriorityQueue&lt;Integer&gt; min = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> o1.compareTo(o2);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(Integer num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>((min.size()+max.size() &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        	<span class="comment">//如果当前总数是偶数，则插入到最大堆</span></span><br><span class="line">        	<span class="keyword">if</span>(min.size() != <span class="number">0</span> &amp;&amp; num &gt; min.peek()) &#123;</span><br><span class="line">        		<span class="comment">//如果最小堆的数目不为0，且新插入的数字比最小堆的头要大</span></span><br><span class="line">        		<span class="keyword">int</span> temp = min.poll();</span><br><span class="line">        		max.add(temp);</span><br><span class="line">        		min.add(num);</span><br><span class="line">        	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        		<span class="comment">//插入到最大堆</span></span><br><span class="line">        		max.add(num);</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        	<span class="comment">//如果当前总数是奇数，则插入到最小堆</span></span><br><span class="line">        	<span class="keyword">if</span>(max.size() != <span class="number">0</span> &amp;&amp; num &lt; max.peek()) &#123;</span><br><span class="line">        		<span class="comment">//同理</span></span><br><span class="line">        		<span class="keyword">int</span> temp = max.poll();</span><br><span class="line">        		min.add(temp);</span><br><span class="line">        		max.add(num);</span><br><span class="line">        	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        		min.add(num);</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Double <span class="title">GetMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = max.size() + min.size();</span><br><span class="line">    	Double d;</span><br><span class="line">    	</span><br><span class="line">    	<span class="keyword">if</span>(size == <span class="number">0</span>)</span><br><span class="line">    		<span class="keyword">return</span> -<span class="number">1.0</span>;</span><br><span class="line">    	</span><br><span class="line">    	<span class="keyword">if</span>((size &amp; <span class="number">1</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">    		d = Double.valueOf(max.peek());</span><br><span class="line">    	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    		d = (<span class="keyword">double</span>) (max.peek() + min.peek()) / <span class="number">2</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span> d;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="42-连续子数组的最大和"><a href="#42-连续子数组的最大和" class="headerlink" title="42 连续子数组的最大和"></a>42 连续子数组的最大和</h2><h3 id="题目描述-43"><a href="#题目描述-43" class="headerlink" title="题目描述"></a>题目描述</h3><p>HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1)</p>
<h3 id="题解-43"><a href="#题解-43" class="headerlink" title="题解"></a>题解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">FindGreatestSumOfSubArray</span><span class="params">(<span class="keyword">int</span>[] data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(data == <span class="keyword">null</span> ||data.length &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> sum=data[<span class="number">0</span>], max=data[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; data.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sum &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">                sum = data[i];</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                sum += data[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(sum &gt; max)&#123;</span><br><span class="line">                max = sum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="44-数字序列中某一位的数字"><a href="#44-数字序列中某一位的数字" class="headerlink" title="44 数字序列中某一位的数字"></a>44 数字序列中某一位的数字</h2><h3 id="题目描述-44"><a href="#题目描述-44" class="headerlink" title="题目描述"></a>题目描述</h3><p>数字以 0123456789101112131415… 的格式序列化到一个字符串中，求这个字符串的第 index 位。</p>
<h3 id="题解-44"><a href="#题解-44" class="headerlink" title="题解"></a>题解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">digitAtIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(index &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> digits = <span class="number">1</span>;	<span class="comment">//digits表示有几位数，初始为一位数</span></span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="keyword">int</span> numbers = countOfIntegers(digits);	<span class="comment">//返回当前位数共有多少个数</span></span><br><span class="line">			<span class="keyword">if</span>(index &lt; numbers * digits) &#123;	<span class="comment">//数字的个数乘位数能得到具体的某一位数字的下标</span></span><br><span class="line">				<span class="keyword">return</span> digitAtIndex(index, digits);</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			index -= digits * numbers;	<span class="comment">//如果要查找的数字不在这位数里面，则跳过这些数字</span></span><br><span class="line">			digits++;	<span class="comment">//位数加一</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 在n位数中的第index个数</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">digitAtIndex</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> digits)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> number = beginNumber(digits) + index / digits;</span><br><span class="line">		<span class="keyword">int</span> indexFromRight = digits - index % digits;	<span class="comment">//得到在查找到的数字中具体从右数的哪一位</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; indexFromRight; i++) &#123;</span><br><span class="line">			number /= <span class="number">10</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> number % <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 计算n位的数字总共有多少，如二位数有10~99这90个数，三位数有100~999这900个数</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">countOfIntegers</span><span class="params">(<span class="keyword">int</span> digits)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(digits == <span class="number">1</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> count = (<span class="keyword">int</span>) Math.pow(<span class="number">10</span>, digits-<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">return</span> count * <span class="number">9</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 计算n位数的第一个数字，如二位数的第一个数字是10，三位数的第一个数字是100</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">beginNumber</span><span class="params">(<span class="keyword">int</span> digits)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(digits == <span class="number">1</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> (<span class="keyword">int</span>)Math.pow(<span class="number">10</span>, digits-<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="45-把数组排成最小的数"><a href="#45-把数组排成最小的数" class="headerlink" title="45 把数组排成最小的数"></a>45 把数组排成最小的数</h2><h3 id="题目描述-45"><a href="#题目描述-45" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。</p>
<h3 id="题解-45"><a href="#题解-45" class="headerlink" title="题解"></a>题解</h3><p>本题的关键在于定义一个规则判断两个数中谁应该排在前面，应该排在前面的数我们称其“小于”另一个数。例如，令m=32，n=2，则mn=322，nm=232，因为nm&lt;mn，我们就称n小于m。之后我们便可使用这个比较方法（比较器）对数组中的所有元素进行排序即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">PrintMinNumber</span><span class="params">(<span class="keyword">int</span> [] numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(numbers == <span class="keyword">null</span> || numbers.length &lt;= <span class="number">0</span>)</span><br><span class="line">    		<span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    	</span><br><span class="line">    	StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    	<span class="keyword">int</span> len = numbers.length;</span><br><span class="line">    	String[] str = <span class="keyword">new</span> String[len];</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    		str[i] = numbers[i] + <span class="string">""</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    	</span><br><span class="line">    	Arrays.sort(str, <span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</span><br><span class="line">    		<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String o1, String o2)</span> </span>&#123;</span><br><span class="line">    			String str1 = o1 + o2;</span><br><span class="line">    			String str2 = o2 + o1;</span><br><span class="line">    			<span class="keyword">return</span> str1.compareTo(str2);</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;);</span><br><span class="line">    	</span><br><span class="line">    	<span class="keyword">for</span>(String s : str) &#123;</span><br><span class="line">    		res.append(s);</span><br><span class="line">    	&#125;</span><br><span class="line">    	</span><br><span class="line">    	<span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="46-把数字翻译成字符串"><a href="#46-把数字翻译成字符串" class="headerlink" title="46 把数字翻译成字符串"></a>46 把数字翻译成字符串</h2><h3 id="题目描述-46"><a href="#题目描述-46" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个数字，按照如下规则翻译成字符串：0 翻译成“a”，1 翻译成“b”… 25 翻译成“z”。一个数字有多种翻译可能，例如 12258 一共有 5 种，分别是 bccfi，bwfi，bczi，mcfi，mzi。实现一个函数，用来计算一个数字有多少种不同的翻译方法。</p>
<h3 id="题解-46"><a href="#题解-46" class="headerlink" title="题解"></a>题解</h3><p>如果用递归方法从上往下求解，必然会遇到许多重复的计算，因此可以从下往上进行求解。</p>
<p>我们可以先得到方程f(i) = f(i+1) + af(i+2)，当第i个数与第i+1个数组成的数字在10-25的范围内，则a=1，否则a=0。以字符串“13225”为例，下标为0和1的数分别是1和3，组成的13是在10-25的范围内的，因此可以将其看成剩下的3225或者225这两种组合方式。以上是自顶向下的分析，再看看自底向上的实现，以下标为2的数2为例，首先就单独把这个数进行翻译，则加上上一个数的计算结果，又因为上一个数2和它组成的22是在10-25的范围内的，所以可以把它们组合在一起翻译，基于这种情况则再加上上上个数的结果，这两种情况的结果相加就是自底到这一个数的计算结果。一直循环到第一个数，dp[0]便是最终答案。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[s.length()+<span class="number">1</span>];</span><br><span class="line">        dp[s.length()] = <span class="number">1</span>;</span><br><span class="line">        dp[s.length()-<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = s.length()-<span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">int</span> a = s.charAt(i) - <span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">int</span> b = s.charAt(i+<span class="number">1</span>) - <span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">if</span>(a * <span class="number">10</span> + b &gt; <span class="number">25</span>)&#123;</span><br><span class="line">                dp[i] = dp[i+<span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i] = dp[i+<span class="number">1</span>] + dp[i+<span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="47-礼物的最大价值"><a href="#47-礼物的最大价值" class="headerlink" title="47 礼物的最大价值"></a>47 礼物的最大价值</h2><h3 id="题目描述-47"><a href="#题目描述-47" class="headerlink" title="题目描述"></a>题目描述</h3><p>小东所在公司要发年终奖，而小东恰好获得了最高福利，他要在公司年会上参与一个抽奖游戏，游戏在一个6*6的棋盘上进行，上面放着36个价值不等的礼物，每个小的棋盘上面放置着一个礼物，他需要从左上角开始游戏，每次只能向下或者向右移动一步，到达右下角停止，一路上的格子里的礼物小东都能拿到，请设计一个算法使小东拿到价值最高的礼物。</p>
<p>给定一个6*6的矩阵board，其中每个元素为对应格子的礼物价值,左上角为[0,0],请返回能获得的最大价值，保证每个礼物价值大于100小于1000。</p>
<h3 id="题解-47"><a href="#题解-47" class="headerlink" title="题解"></a>题解</h3><p>使用动态规划的思路：f(i,j) = max(f(i-1,j), f(i,j-1))，每一个坐标(i,j)的解只需要依赖其左边与上边的坐标，且最左边坐标的解只依赖上边的坐标，因此只需要一个一维数组作为缓存即可，该数组存有i行j列左边的所有解以及i-1行j列右边的所有解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMost</span><span class="params">(<span class="keyword">int</span>[][] values)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(values == <span class="keyword">null</span> || values.length == <span class="number">0</span> || values[<span class="number">0</span>].length == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> n = values[<span class="number">0</span>].length;</span><br><span class="line">		<span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span>[] value : values) &#123;</span><br><span class="line">			dp[<span class="number">0</span>] += value[<span class="number">0</span>];</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">				dp[i] = Math.max(dp[i], dp[i-<span class="number">1</span>]) + value[i];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> dp[n-<span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="48-最长不含重复字符的子字符串"><a href="#48-最长不含重复字符的子字符串" class="headerlink" title="48 最长不含重复字符的子字符串"></a>48 最长不含重复字符的子字符串</h2><h3 id="题目描述-48"><a href="#题目描述-48" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个字符串（只包含 a~z 的字符），求其最长不含重复字符的子字符串的长度。例如对于 arabcacfr，最长不含重复字符的子字符串为 acfr，长度为 4。</p>
<h3 id="题解-48"><a href="#题解-48" class="headerlink" title="题解"></a>题解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">LongestSubstringWithoutDupSolution</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(str == <span class="keyword">null</span> || str.length() &lt;= <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> curLen = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span>[] position = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">			position[i] = -<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">			<span class="comment">//当前字母在position的下标index</span></span><br><span class="line">			<span class="keyword">int</span> index = str.charAt(i) - <span class="string">'a'</span>;</span><br><span class="line">			<span class="keyword">if</span>(position[index] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="comment">//如果这个字母之前没出现过</span></span><br><span class="line">				curLen += <span class="number">1</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">if</span>(i-position[index] &lt;= curLen) &#123;</span><br><span class="line">					curLen = i-position[index];</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					curLen += <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			position[index] = i;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span>(curLen &gt; maxLen)</span><br><span class="line">				maxLen = curLen;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> maxLen;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="49-丑数"><a href="#49-丑数" class="headerlink" title="49 丑数"></a>49 丑数</h2><h3 id="题目描述-49"><a href="#题目描述-49" class="headerlink" title="题目描述"></a>题目描述</h3><p>把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。</p>
<h3 id="题解-49"><a href="#题解-49" class="headerlink" title="题解"></a>题解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GetUglyNumber_Solution</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(index &lt;= <span class="number">6</span>)</span><br><span class="line">    		<span class="keyword">return</span> index;</span><br><span class="line">    	</span><br><span class="line">    	<span class="keyword">int</span>[] ugly = <span class="keyword">new</span> <span class="keyword">int</span>[index];</span><br><span class="line">    	ugly[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    	</span><br><span class="line">    	<span class="keyword">int</span> t2=<span class="number">0</span>, t3=<span class="number">0</span>, t5=<span class="number">0</span>;</span><br><span class="line">    	</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; index; i++) &#123;</span><br><span class="line">    		ugly[i] = Math.min(ugly[t2]*<span class="number">2</span>, Math.min(ugly[t3]*<span class="number">3</span>, ugly[t5]*<span class="number">5</span>));</span><br><span class="line">    		<span class="keyword">while</span>(ugly[t2] * <span class="number">2</span> &lt;= ugly[i])</span><br><span class="line">    			t2++;</span><br><span class="line">    		<span class="keyword">while</span>(ugly[t3] * <span class="number">3</span> &lt;= ugly[i])</span><br><span class="line">    			t3++;</span><br><span class="line">    		<span class="keyword">while</span>(ugly[t5] * <span class="number">5</span> &lt;= ugly[i])</span><br><span class="line">    			t5++;</span><br><span class="line">    	&#125;</span><br><span class="line">        <span class="keyword">return</span> ugly[ugly.length-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="50-1-第一个只出现一次的字符"><a href="#50-1-第一个只出现一次的字符" class="headerlink" title="50.1 第一个只出现一次的字符"></a>50.1 第一个只出现一次的字符</h2><h3 id="题目描述-50"><a href="#题目描述-50" class="headerlink" title="题目描述"></a>题目描述</h3><p>在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）.</p>
<h3 id="题解-50"><a href="#题解-50" class="headerlink" title="题解"></a>题解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">FirstNotRepeatingChar</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(str == <span class="keyword">null</span>)</span><br><span class="line">    		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    	</span><br><span class="line">        HashMap&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> index = -<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">        	<span class="keyword">char</span> curr = str.charAt(i);</span><br><span class="line">        	<span class="keyword">if</span>(!map.containsKey(curr)) &#123;</span><br><span class="line">        		map.put(curr, <span class="number">1</span>);</span><br><span class="line">        	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        		<span class="keyword">int</span> value = map.get(curr);</span><br><span class="line">        		map.put(curr, ++value);</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">        	<span class="keyword">char</span> curr = str.charAt(i);</span><br><span class="line">        	<span class="keyword">if</span>(map.get(curr) == <span class="number">1</span>) &#123;</span><br><span class="line">        		index = i;</span><br><span class="line">        		<span class="keyword">break</span>;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="50-2-字符流中第一个不重复的字符"><a href="#50-2-字符流中第一个不重复的字符" class="headerlink" title="50.2 字符流中第一个不重复的字符"></a>50.2 字符流中第一个不重复的字符</h2><h3 id="题目描述-51"><a href="#题目描述-51" class="headerlink" title="题目描述"></a>题目描述</h3><p>请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是”l”。</p>
<h3 id="题解-51"><a href="#题解-51" class="headerlink" title="题解"></a>题解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span>[] map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Solution</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; map.length; i++) &#123;</span><br><span class="line">			map[i] = -<span class="number">1</span>;	<span class="comment">//-1代表从未出现过</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//Insert one char from stringstream</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(map[ch] == -<span class="number">1</span>) &#123;</span><br><span class="line">        	map[ch] = index;	<span class="comment">//从未出现过，将它的下标赋值给它</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        	map[ch] = -<span class="number">2</span>;		<span class="comment">//出现过，则值为-2</span></span><br><span class="line">        &#125;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//return the first appearence once char in current stringstream</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">FirstAppearingOnce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">char</span> result = <span class="string">'#'</span>;</span><br><span class="line">    	<span class="keyword">int</span> minIndex = Integer.MAX_VALUE;</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; map.length; i++) &#123;</span><br><span class="line">    		<span class="keyword">if</span>(map[i] &gt;= <span class="number">0</span> &amp;&amp; map[i] &lt; minIndex) &#123;</span><br><span class="line">    			minIndex = map[i];</span><br><span class="line">    			result = (<span class="keyword">char</span>)i;</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="51-数组中的逆序对"><a href="#51-数组中的逆序对" class="headerlink" title="51 数组中的逆序对"></a>51 数组中的逆序对</h2><h3 id="题目描述-52"><a href="#题目描述-52" class="headerlink" title="题目描述"></a>题目描述</h3><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007</p>
<h3 id="题解-52"><a href="#题解-52" class="headerlink" title="题解"></a>题解</h3><p>统计逆序对的过程：先把数组分隔成子数组，统计出子数组内部的逆序对的数目，然后再统计出两个相邻子数组之间的逆序对的数目。在统计逆序对的过程中，还需要对数组进行归并排序，而计算逆序对数目其实就是在进行归并排序的时候完成的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">long</span> cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span>[] tmp;</span><br><span class="line">	</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">InversePairs</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">    	tmp = <span class="keyword">new</span> <span class="keyword">int</span>[array.length];</span><br><span class="line">        <span class="keyword">if</span>(array == <span class="keyword">null</span> || array.length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        	<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        mergeSort(array, <span class="number">0</span>, array.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) (cnt % <span class="number">1000000007</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(hi &lt;= lo)</span><br><span class="line">    		<span class="keyword">return</span>;</span><br><span class="line">    	<span class="keyword">int</span> m = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">    	</span><br><span class="line">    	mergeSort(a, lo, m);</span><br><span class="line">    	mergeSort(a, m+<span class="number">1</span>, hi);</span><br><span class="line">    	merge(a, lo, m, hi);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> m, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">int</span> i = lo, j = m+<span class="number">1</span>, k = lo;</span><br><span class="line">    	<span class="keyword">while</span>(k &lt;= hi) &#123;</span><br><span class="line">    		<span class="keyword">if</span>(i &gt; m) &#123;</span><br><span class="line">    			tmp[k] = a[j++];</span><br><span class="line">    		&#125; <span class="keyword">else</span> <span class="keyword">if</span>(j &gt; hi) &#123;</span><br><span class="line">    			tmp[k] = a[i++];</span><br><span class="line">    		&#125; <span class="keyword">else</span> <span class="keyword">if</span>(a[i] &lt; a[j]) &#123;</span><br><span class="line">    			tmp[k] = a[i++];</span><br><span class="line">    		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    			tmp[k] = a[j++];</span><br><span class="line">    			cnt += m - i + <span class="number">1</span>;</span><br><span class="line">    		&#125;</span><br><span class="line">    		k++;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">for</span>(k = lo; k &lt;= hi; k++) &#123;</span><br><span class="line">    		a[k] = tmp[k];</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="52-两个链表的第一个公共结点"><a href="#52-两个链表的第一个公共结点" class="headerlink" title="52 两个链表的第一个公共结点"></a>52 两个链表的第一个公共结点</h2><h3 id="题目描述-53"><a href="#题目描述-53" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入两个链表，找出它们的第一个公共结点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    ListNode next = null;</span><br><span class="line"></span><br><span class="line">    ListNode(int val) &#123;</span><br><span class="line">        this.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="题解-53"><a href="#题解-53" class="headerlink" title="题解"></a>题解</h3><p>此题大体有两种思路：</p>
<p>1、如果从后往前遍历两条链表，那么最后一个相同的节点就是我们要找的节点。这种思路要解决的问题在于链表是单向链表，该怎么逆序遍历链表。</p>
<p>2、如果从前往后遍历两条链表，那么第一个相同的节点就是我们要找的节点。这种思路要解决的问题在于如果两条链表的长度不同，便无法同时到达第一个公共节点，进而也就无法比较是否相等。</p>
<h4 id="思路一：以空间换时间"><a href="#思路一：以空间换时间" class="headerlink" title="思路一：以空间换时间"></a>思路一：以空间换时间</h4><p>将两个链表分别装到两个栈中，每次取出链表尾部的一个节点判断是否相等，最后一个相等的节点即为两个链表的第一个公共节点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">FindFirstCommonNode</span><span class="params">(ListNode pHead1, ListNode pHead2)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(pHead1 == <span class="keyword">null</span> || pHead2 == <span class="keyword">null</span>)</span><br><span class="line">    		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    	</span><br><span class="line">    	Stack&lt;ListNode&gt; stack1 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    	Stack&lt;ListNode&gt; stack2 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    	ListNode h1 = pHead1;</span><br><span class="line">    	ListNode h2 = pHead2;</span><br><span class="line">    	ListNode common = <span class="keyword">null</span>;</span><br><span class="line">    	<span class="keyword">while</span>(h1!=<span class="keyword">null</span>)</span><br><span class="line">    	&#123;</span><br><span class="line">    		stack1.push(h1);</span><br><span class="line">    		h1 = h1.next;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">while</span>(h2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">    		stack2.push(h2);</span><br><span class="line">    		h2 = h2.next;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">while</span>(!stack1.empty() &amp;&amp; !stack2.empty()) &#123;</span><br><span class="line">    		ListNode node1 = stack1.pop();</span><br><span class="line">    		ListNode node2 = stack2.pop();</span><br><span class="line">    		<span class="keyword">if</span>(node1 == node2) &#123;</span><br><span class="line">    			common = node1;</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span> common;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="思路二：进一步优化"><a href="#思路二：进一步优化" class="headerlink" title="思路二：进一步优化"></a>思路二：进一步优化</h4><p>上一种思路需要两个栈作为辅助空间，其实完全可以不用辅助空间，先分别遍历两个链表并记录他们的长度，长链表先走几步以此和短链表在同一起点出发，之后便可以同时遍历直至找出相同的节点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">FindFirstCommonNode</span><span class="params">(ListNode pHead1, ListNode pHead2)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(pHead1 == <span class="keyword">null</span> || pHead2 == <span class="keyword">null</span>)</span><br><span class="line">    		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    	</span><br><span class="line">    	<span class="keyword">int</span> len1 = <span class="number">0</span>;</span><br><span class="line">    	<span class="keyword">int</span> len2 = <span class="number">0</span>;</span><br><span class="line">    	<span class="keyword">int</span> diff;				<span class="comment">//两条链表的长度差</span></span><br><span class="line">    	ListNode listLong;		<span class="comment">//标识链表的长短</span></span><br><span class="line">    	ListNode listShort;</span><br><span class="line">    	ListNode h1 = pHead1;	<span class="comment">//用于遍历的节点</span></span><br><span class="line">    	ListNode h2 = pHead2;</span><br><span class="line">    	</span><br><span class="line">    	<span class="keyword">while</span>(h1!=<span class="keyword">null</span>)</span><br><span class="line">    	&#123;</span><br><span class="line">    		len1++;</span><br><span class="line">    		h1 = h1.next;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">while</span>(h2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">    		len2++;</span><br><span class="line">    		h2 = h2.next;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">if</span>(len1 &gt; len2) &#123;</span><br><span class="line">    		listLong = pHead1;</span><br><span class="line">    		listShort = pHead2;</span><br><span class="line">    		diff = len1 - len2;</span><br><span class="line">    	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    		listLong = pHead2;</span><br><span class="line">    		listShort = pHead1;</span><br><span class="line">    		diff = len2 - len1;</span><br><span class="line">    	&#125;</span><br><span class="line">    	</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; diff; i++) &#123;</span><br><span class="line">    		listLong = listLong.next;</span><br><span class="line">    	&#125;</span><br><span class="line">    	</span><br><span class="line">    	<span class="keyword">while</span>(listLong != <span class="keyword">null</span> &amp;&amp; listShort != <span class="keyword">null</span>) &#123;</span><br><span class="line">    		<span class="keyword">if</span>(listLong == listShort)</span><br><span class="line">    			<span class="keyword">return</span> listLong;</span><br><span class="line">    		listLong = listLong.next;</span><br><span class="line">    		listShort = listShort.next;</span><br><span class="line">    	&#125;</span><br><span class="line">    	</span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="53-1-数字在排序数组中出现的次数"><a href="#53-1-数字在排序数组中出现的次数" class="headerlink" title="53.1 数字在排序数组中出现的次数"></a>53.1 数字在排序数组中出现的次数</h2><h3 id="题目描述-54"><a href="#题目描述-54" class="headerlink" title="题目描述"></a>题目描述</h3><p>统计一个数字在排序数组中出现的次数。</p>
<h3 id="题解-54"><a href="#题解-54" class="headerlink" title="题解"></a>题解</h3><p>最直观的做法是顺序扫描，时间复杂度为O(n)，不是最优解。由于输入的数组是排序的，那么就可以用二分查找的思路，找到第一个要查找的数字和最后一个要查找的数字，其坐标差即为该数字出现的次数。此时时间复杂度为O(logn)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GetNumberOfK</span><span class="params">(<span class="keyword">int</span> [] array , <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(array ==  <span class="keyword">null</span> || array.length &lt;= <span class="number">0</span>)</span><br><span class="line">        	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> start = getFirstK(array, k);</span><br><span class="line">        <span class="keyword">int</span> end = getLastK(array, k);</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(start != -<span class="number">1</span> &amp;&amp; end != -<span class="number">1</span>) &#123;</span><br><span class="line">        	num = end - start + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getFirstK</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">int</span> lo = <span class="number">0</span>;</span><br><span class="line">    	<span class="keyword">int</span> hi = array.length - <span class="number">1</span>;</span><br><span class="line">    	<span class="keyword">int</span> middle;</span><br><span class="line">    	<span class="keyword">while</span>(lo &lt;= hi) &#123;</span><br><span class="line">    		middle = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">    		<span class="keyword">if</span>(array[middle] &lt; k) &#123;</span><br><span class="line">    			lo = middle + <span class="number">1</span>;</span><br><span class="line">    		&#125; <span class="keyword">else</span> <span class="keyword">if</span>(array[middle] &gt; k) &#123;</span><br><span class="line">    			hi = middle - <span class="number">1</span>;</span><br><span class="line">    		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    			<span class="keyword">if</span>(middle - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; array[middle - <span class="number">1</span>] == k) &#123;</span><br><span class="line">    				 hi = middle - <span class="number">1</span>;</span><br><span class="line">    			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    				<span class="keyword">return</span> middle;</span><br><span class="line">    			&#125;</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLastK</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">int</span> lo = <span class="number">0</span>;</span><br><span class="line">    	<span class="keyword">int</span> hi = array.length - <span class="number">1</span>;</span><br><span class="line">    	<span class="keyword">int</span> middle;</span><br><span class="line">    	<span class="keyword">while</span>(lo &lt;= hi) &#123;</span><br><span class="line">    		middle = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">    		<span class="keyword">if</span>(array[middle] &lt; k) &#123;</span><br><span class="line">    			lo = middle + <span class="number">1</span>;</span><br><span class="line">    		&#125; <span class="keyword">else</span> <span class="keyword">if</span>(array[middle] &gt; k) &#123;</span><br><span class="line">    			hi = middle - <span class="number">1</span>;</span><br><span class="line">    		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    			<span class="keyword">if</span>(middle + <span class="number">1</span> &lt; array.length &amp;&amp; array[middle + <span class="number">1</span>] == k) &#123;</span><br><span class="line">    				 lo = middle + <span class="number">1</span>;</span><br><span class="line">    			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    				<span class="keyword">return</span> middle;</span><br><span class="line">    			&#125;</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="53-2-0至n-1中缺失的数字"><a href="#53-2-0至n-1中缺失的数字" class="headerlink" title="53.2 0至n-1中缺失的数字"></a>53.2 0至n-1中缺失的数字</h2><h3 id="题目描述-55"><a href="#题目描述-55" class="headerlink" title="题目描述"></a>题目描述</h3><p>在范围0~n-1内的n个数字中有且只有一个数字不在长度为n-1的递增排序数组（数字唯一）中，请找出这个数字。例如，{1,2,3,4}中少了0，{0,1,2,3}中少了4，{0,1,3,4}中少了2。</p>
<h3 id="题解-55"><a href="#题解-55" class="headerlink" title="题解"></a>题解</h3><p>用二分查找法找到第一个数字与下标不同的元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMissingNumber</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(array ==  <span class="keyword">null</span> || array.length &lt;= <span class="number">0</span>)</span><br><span class="line">        	<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    	<span class="keyword">int</span> lo = <span class="number">0</span>;</span><br><span class="line">    	<span class="keyword">int</span> hi = array.length - <span class="number">1</span>;</span><br><span class="line">    	<span class="keyword">int</span> middle;</span><br><span class="line">    	<span class="keyword">while</span>(lo &lt;= hi) &#123;</span><br><span class="line">    		middle = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">    		<span class="keyword">if</span>(array[middle] == middle) &#123;</span><br><span class="line">    			lo = middle + <span class="number">1</span>;</span><br><span class="line">    		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    			<span class="keyword">if</span>(middle - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; array[middle - <span class="number">1</span>] != middle - <span class="number">1</span>) &#123;</span><br><span class="line">    				 hi = middle - <span class="number">1</span>;</span><br><span class="line">    			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    				<span class="keyword">return</span> middle;</span><br><span class="line">    			&#125;</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span> array.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="53-3-数组中数值和下标相等的元素"><a href="#53-3-数组中数值和下标相等的元素" class="headerlink" title="53.3 数组中数值和下标相等的元素"></a>53.3 数组中数值和下标相等的元素</h2><h3 id="题目描述-56"><a href="#题目描述-56" class="headerlink" title="题目描述"></a>题目描述</h3><p>假设一个单调递增的数组里的每个元素都是整数并且是唯一的。请编写实现一个函数，找出数组中任意一个数值等于其下标的元素。</p>
<h3 id="题解-56"><a href="#题解-56" class="headerlink" title="题解"></a>题解</h3><p>由于每个数都是唯一的，如果第i个数字的值大于i，那么它右边的数字都大于对应的下标；如果第i个数字的值小于i，那么它左边的数字都小于对应的下标。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">IntegerIdenticalToIndex</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(array ==  <span class="keyword">null</span> || array.length &lt;= <span class="number">0</span>)</span><br><span class="line">        	<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    	<span class="keyword">int</span> lo = <span class="number">0</span>;</span><br><span class="line">    	<span class="keyword">int</span> hi = array.length - <span class="number">1</span>;</span><br><span class="line">    	<span class="keyword">int</span> middle;</span><br><span class="line">    	<span class="keyword">while</span>(lo &lt;= hi) &#123;</span><br><span class="line">    		middle = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">    		<span class="keyword">if</span>(array[middle] &gt; middle) &#123;</span><br><span class="line">    			hi = middle - <span class="number">1</span>;</span><br><span class="line">    		&#125; <span class="keyword">else</span> <span class="keyword">if</span>(array[middle] &lt; middle) &#123;</span><br><span class="line">    			lo = middle + <span class="number">1</span>;</span><br><span class="line">    		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    			<span class="keyword">if</span>(middle - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; array[middle - <span class="number">1</span>] == middle - <span class="number">1</span>) &#123;</span><br><span class="line">	   				 hi = middle - <span class="number">1</span>;</span><br><span class="line">	   			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	   				<span class="keyword">return</span> middle;</span><br><span class="line">	   			&#125;</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="54-二叉搜索树的第k个结点"><a href="#54-二叉搜索树的第k个结点" class="headerlink" title="54 二叉搜索树的第k个结点"></a>54 二叉搜索树的第k个结点</h2><h3 id="题目描述-57"><a href="#题目描述-57" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一棵二叉搜索树，请找出其中的第k小的结点。例如，（5，3，7，2，4，6，8）中，按结点数值大小顺序第三小结点的值为4。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class TreeNode &#123;</span><br><span class="line">    int val = 0;</span><br><span class="line">    TreeNode left = null;</span><br><span class="line">    TreeNode right = null;</span><br><span class="line"></span><br><span class="line">    public TreeNode(int val) &#123;</span><br><span class="line">        this.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="题解-57"><a href="#题解-57" class="headerlink" title="题解"></a>题解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> cnt;</span><br><span class="line">	<span class="keyword">private</span> TreeNode target;</span><br><span class="line">	</span><br><span class="line">    <span class="function">TreeNode <span class="title">KthNode</span><span class="params">(TreeNode pRoot, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="keyword">null</span> || k &lt;= <span class="number">0</span>)</span><br><span class="line">        	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        KthNodeCore(pRoot, k);</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">KthNodeCore</span><span class="params">(TreeNode pRoot, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(pRoot == <span class="keyword">null</span> || target != <span class="keyword">null</span>) &#123;</span><br><span class="line">    		<span class="keyword">return</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    	KthNodeCore(pRoot.left, k);</span><br><span class="line">    	cnt++;</span><br><span class="line">    	<span class="keyword">if</span>(cnt == k)</span><br><span class="line">    		target = pRoot;</span><br><span class="line">    	KthNodeCore(pRoot.right, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="55-1-二叉树的深度"><a href="#55-1-二叉树的深度" class="headerlink" title="55.1 二叉树的深度"></a>55.1 二叉树的深度</h2><h3 id="题目描述-58"><a href="#题目描述-58" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class TreeNode &#123;</span><br><span class="line">    int val = 0;</span><br><span class="line">    TreeNode left = null;</span><br><span class="line">    TreeNode right = null;</span><br><span class="line"></span><br><span class="line">    public TreeNode(int val) &#123;</span><br><span class="line">        this.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="题解-58"><a href="#题解-58" class="headerlink" title="题解"></a>题解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">TreeDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = TreeDepth(root.left);</span><br><span class="line">        <span class="keyword">int</span> right = TreeDepth(root.right);</span><br><span class="line">        <span class="keyword">return</span> left &gt; right ? (left+<span class="number">1</span>):(right+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="55-2-平衡二叉树"><a href="#55-2-平衡二叉树" class="headerlink" title="55.2 平衡二叉树"></a>55.2 平衡二叉树</h2><h3 id="题目描述-59"><a href="#题目描述-59" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一棵二叉树，判断该二叉树是否是平衡二叉树。</p>
<h3 id="题解-59"><a href="#题解-59" class="headerlink" title="题解"></a>题解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsBalanced_Solution</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> IsBalanced(root) != -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">IsBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">    		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    	<span class="keyword">int</span> left = IsBalanced(root.left);</span><br><span class="line">    	<span class="keyword">if</span>(left == -<span class="number">1</span>)</span><br><span class="line">    		<span class="keyword">return</span> left;</span><br><span class="line">    	<span class="keyword">int</span> right = IsBalanced(root.right);</span><br><span class="line">    	<span class="keyword">if</span>(right == -<span class="number">1</span>)</span><br><span class="line">    		<span class="keyword">return</span> right;</span><br><span class="line">    	<span class="keyword">return</span> Math.abs(left-right) &gt; <span class="number">1</span> ? -<span class="number">1</span> : <span class="number">1</span>+Math.max(left,right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="56-1-数组中只出现一次的数字"><a href="#56-1-数组中只出现一次的数字" class="headerlink" title="56.1 数组中只出现一次的数字"></a>56.1 数组中只出现一次的数字</h2><h3 id="题目描述-60"><a href="#题目描述-60" class="headerlink" title="题目描述"></a>题目描述</h3><p>一个整型数组里除了两个数字之外，其他的数字都出现了偶数次。请写程序找出这两个只出现一次的数字。</p>
<h3 id="题解-60"><a href="#题解-60" class="headerlink" title="题解"></a>题解</h3><p>因为任何一个数字异或它自己都等于0，而0异或任何一个数字都等于其本身，所以可以将数组中的所有数字都异或，例如对于含有一个数字只出现一次的数组{3,3,4,4,6}：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    3 ^ 3 ^ 4 ^ 4 ^ 6</span><br><span class="line">-&gt;  0 ^ 0 ^ 6</span><br><span class="line">-&gt;  6</span><br></pre></td></tr></table></figure></p>
<p>而在此题中，数组里有两个数字只出现了一次，所以从头到尾异或数组中的每个数字会得到这两个数字的异或结果，由于这两个数字肯定不同，所以异或结果至少会包含一个1，我们以最右侧的1为标准将这两个数分到两个子数组中，于此同时这一位为1或0的出现两次的数字也会分别到这两个子数组中，然后再对两个子数组运用最上面的思路。</p>
<p>在这里，diff &amp;= -diff可以得到只有最右侧为1的数，以此作为分割标准。（在计算机中，负数以其正值的补码形式表达，补码=反码+1）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FindNumsAppearOnce</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> num1[], <span class="keyword">int</span> num2[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> diff = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums)</span><br><span class="line">            diff ^= num;</span><br><span class="line">        diff &amp;= -diff;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((num &amp; diff) == <span class="number">0</span>)</span><br><span class="line">                num1[<span class="number">0</span>] ^= num;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                num2[<span class="number">0</span>] ^= num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="56-2-数组中唯一只出现一次的数字"><a href="#56-2-数组中唯一只出现一次的数字" class="headerlink" title="56.2 数组中唯一只出现一次的数字"></a>56.2 数组中唯一只出现一次的数字</h2><h3 id="题目描述-61"><a href="#题目描述-61" class="headerlink" title="题目描述"></a>题目描述</h3><p>在一个数组中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。</p>
<h3 id="题解-61"><a href="#题解-61" class="headerlink" title="题解"></a>题解</h3><p>把数组中所有数字的二进制表示的每一位都加起来，如果某一位的和能被3整除，那么那个只出现一次的数字二进制表示中对应的那一位是0，否则就是1。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NumberAppearingOnce</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solution</span><span class="params">(<span class="keyword">int</span> numbers[])</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(numbers == <span class="keyword">null</span> || numbers.length == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">int</span>[] bitSum = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">32</span>];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numbers.length; i++) &#123;</span><br><span class="line">			<span class="keyword">int</span> bitMask = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">31</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">				<span class="keyword">int</span> bit = numbers[i] &amp; bitMask;</span><br><span class="line">				<span class="keyword">if</span>(bit != <span class="number">0</span>)</span><br><span class="line">					bitSum[j] += <span class="number">1</span>;</span><br><span class="line">				bitMask = bitMask &lt;&lt; <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">			result = result &lt;&lt; <span class="number">1</span>;</span><br><span class="line">			result += bitSum[i] % <span class="number">3</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="57-1-和为s的两个数字"><a href="#57-1-和为s的两个数字" class="headerlink" title="57.1 和为s的两个数字"></a>57.1 和为s的两个数字</h2><h3 id="题目描述-62"><a href="#题目描述-62" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。</p>
<h3 id="题解-62"><a href="#题解-62" class="headerlink" title="题解"></a>题解</h3><p>定义两个指针，一个指向数组头，一个指向数组末尾，如果指针指向的这两个数字相加小于S，则将头指针向后移动一位，否则将尾指针向前移动一位。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">FindNumbersWithSum</span><span class="params">(<span class="keyword">int</span> [] array,<span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    	<span class="keyword">if</span>(array == <span class="keyword">null</span> || array.length == <span class="number">0</span>)</span><br><span class="line">    		<span class="keyword">return</span> result;</span><br><span class="line">    	</span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> hi = array.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(lo &lt; hi) &#123;</span><br><span class="line">        	<span class="keyword">int</span> curSum = array[lo] + array[hi];</span><br><span class="line">        	<span class="keyword">if</span>(curSum &lt; sum) &#123;</span><br><span class="line">        		 lo++;</span><br><span class="line">        	&#125; <span class="keyword">else</span> <span class="keyword">if</span>(curSum &gt; sum) &#123;</span><br><span class="line">        		hi--;</span><br><span class="line">        	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        		result.add(array[lo]);</span><br><span class="line">        		result.add(array[hi]);</span><br><span class="line">        		<span class="keyword">break</span>;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="57-2-和为s的连续正数序列"><a href="#57-2-和为s的连续正数序列" class="headerlink" title="57.2 和为s的连续正数序列"></a>57.2 和为s的连续正数序列</h2><h3 id="题目描述-63"><a href="#题目描述-63" class="headerlink" title="题目描述"></a>题目描述</h3><p>小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck!</p>
<h3 id="题解-63"><a href="#题解-63" class="headerlink" title="题解"></a>题解</h3><p>首先把lo和hi分别初始化为1和2（因为连续序列为正，且至少含有两个数字），如果lo和hi之间的数字相加大于S，将lo加一，而如果lo和hi之间的数字相加小于S，则将hi加一。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt; &gt; FindContinuousSequence(<span class="keyword">int</span> sum) &#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; listAll = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(sum &lt;= <span class="number">0</span>)</span><br><span class="line">        	<span class="keyword">return</span> listAll;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> hi = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> middle = sum / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> curSum = lo + hi;</span><br><span class="line">        <span class="keyword">while</span>(lo &lt;= middle) &#123;</span><br><span class="line">        	<span class="keyword">if</span>(curSum &lt; sum) &#123;</span><br><span class="line">        		hi++;</span><br><span class="line">        		curSum += hi;</span><br><span class="line">        	&#125; <span class="keyword">else</span> <span class="keyword">if</span>(curSum &gt; sum) &#123;</span><br><span class="line">        		curSum -= lo;</span><br><span class="line">        		lo++;</span><br><span class="line">        	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        		ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        		<span class="keyword">int</span> i = lo;</span><br><span class="line">        		<span class="keyword">while</span>(i &lt;= hi)</span><br><span class="line">        			list.add(i++);</span><br><span class="line">        		listAll.add(list);</span><br><span class="line">        		curSum += ++hi;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> listAll;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="58-1-翻转单词序列"><a href="#58-1-翻转单词序列" class="headerlink" title="58.1 翻转单词序列"></a>58.1 翻转单词序列</h2><h3 id="题目描述-64"><a href="#题目描述-64" class="headerlink" title="题目描述"></a>题目描述</h3><p>牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？</p>
<h3 id="题解-64"><a href="#题解-64" class="headerlink" title="题解"></a>题解</h3><p>进行两次翻转：首先将整体进行翻转，得到<code>.tneduts a ma I</code>，再将每个单词进行局部翻转，得到<code>student. a am I</code>即为答案。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">ReverseSentence</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(str == <span class="keyword">null</span>)</span><br><span class="line">    		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    	<span class="keyword">else</span> <span class="keyword">if</span>(str == <span class="string">""</span>)</span><br><span class="line">    		<span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">char</span>[] data = str.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = data.length-<span class="number">1</span>;</span><br><span class="line">        reverse(data, i, j);</span><br><span class="line">        j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; data.length) &#123;</span><br><span class="line">        	<span class="keyword">if</span>(j == data.length || data[j] == <span class="string">' '</span>) &#123;</span><br><span class="line">        		reverse(data, i, j-<span class="number">1</span>);</span><br><span class="line">        		i = j + <span class="number">1</span>;</span><br><span class="line">        	&#125;</span><br><span class="line">        	j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(data);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">char</span>[] data, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">while</span>(i &lt;= j) &#123;</span><br><span class="line">    		<span class="keyword">char</span> temp = data[i];</span><br><span class="line">    		data[i] = data[j];</span><br><span class="line">    		data[j] = temp;</span><br><span class="line">    		i++;</span><br><span class="line">    		j--;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="58-2-左旋转字符串"><a href="#58-2-左旋转字符串" class="headerlink" title="58.2 左旋转字符串"></a>58.2 左旋转字符串</h2><h3 id="题目描述-65"><a href="#题目描述-65" class="headerlink" title="题目描述"></a>题目描述</h3><p>汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！</p>
<h3 id="题解-65"><a href="#题解-65" class="headerlink" title="题解"></a>题解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">LeftRotateString</span><span class="params">(String str,<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(str == <span class="keyword">null</span>)</span><br><span class="line">    		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    	<span class="keyword">else</span> <span class="keyword">if</span>(str == <span class="string">""</span>)</span><br><span class="line">    		<span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    	<span class="keyword">else</span> <span class="keyword">if</span>(n &gt;= str.length())</span><br><span class="line">    		<span class="keyword">return</span> str;</span><br><span class="line">    	</span><br><span class="line">        <span class="keyword">char</span>[] data = str.toCharArray();</span><br><span class="line">        reverse(data, <span class="number">0</span>, n-<span class="number">1</span>);</span><br><span class="line">        reverse(data, n, data.length-<span class="number">1</span>);</span><br><span class="line">        reverse(data, <span class="number">0</span>, data.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(data);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">char</span>[] data, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">while</span>(i &lt;= j) &#123;</span><br><span class="line">    		<span class="keyword">char</span> temp = data[i];</span><br><span class="line">    		data[i] = data[j];</span><br><span class="line">    		data[j] = temp;</span><br><span class="line">    		i++;</span><br><span class="line">    		j--;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="60-n个骰子的点数"><a href="#60-n个骰子的点数" class="headerlink" title="60 n个骰子的点数"></a>60 n个骰子的点数</h2><h3 id="题目描述-66"><a href="#题目描述-66" class="headerlink" title="题目描述"></a>题目描述</h3><p>把 n 个骰子仍在地上，求点数和为 s 的概率。</p>
<h3 id="题解-66"><a href="#题解-66" class="headerlink" title="题解"></a>题解</h3><p>我们以n表示要扔的骰子数，s为所有骰子的点数之和，f(n, s)表示扔n个骰子时所有骰子的点数之和为s的排列情况总数。例如，n=2，s=5时，f(n, s) = f(2, 5) = 4 （4种情况即<code>{1, 4}, {4, 1}, {2, 3}, {3, 2}</code>）</p>
<p>因为一个骰子有六个点数，那么第n个骰子可能出现1到6的点数，当第n个骰子点数为1的话，f(n,s) = f(n-1, s-1)，当第n个骰子点数为2的话，f(n,s) = f(n-1, s-2)，…，依次类推。</p>
<p>由以上分析我们便可以得到状态转移方程：<code>f(n,s)=f(n-1,s-1)+f(n-1,s-2)+f(n-1,s-3)+f(n-1,s-4)+f(n-1,s-5)+f(n-1,s-6)</code></p>
<h4 id="使用递归-1"><a href="#使用递归-1" class="headerlink" title="使用递归"></a>使用递归</h4><p>得到状态方程后，最直观的就是使用递归求解。点数和的最小值为骰子数n，而最大值为6 * n。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> List&lt;Map.Entry&lt;Integer, Double&gt;&gt; dicesSum(<span class="keyword">int</span> n) &#123;</span><br><span class="line">		List&lt;Map.Entry&lt;Integer, Double&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		<span class="keyword">int</span> minSum = n;</span><br><span class="line">		<span class="keyword">int</span> maxSum = <span class="number">6</span> * n;</span><br><span class="line">		<span class="keyword">double</span> totalCase = Math.pow(<span class="number">6</span>, n);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = minSum; i &lt;= maxSum; i++) &#123;</span><br><span class="line">			result.add(<span class="keyword">new</span> AbstractMap.SimpleEntry&lt;&gt;(i, dicesSumCore(n, i) / totalCase));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dicesSumCore</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> sum)</span></span>&#123;</span><br><span class="line">	    <span class="keyword">if</span>(n&lt;<span class="number">1</span>||sum&lt;n||sum&gt;<span class="number">6</span>*n)&#123;</span><br><span class="line">	        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">	        <span class="keyword">return</span>  <span class="number">1</span>;</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">int</span> resCount=<span class="number">0</span>;</span><br><span class="line">	    resCount=dicesSumCore(n-<span class="number">1</span>,sum-<span class="number">1</span>)+dicesSumCore(n-<span class="number">1</span>,sum-<span class="number">2</span>)+</span><br><span class="line">	    		dicesSumCore(n-<span class="number">1</span>,sum-<span class="number">3</span>)+dicesSumCore(n-<span class="number">1</span>,sum-<span class="number">4</span>)+</span><br><span class="line">	    		dicesSumCore(n-<span class="number">1</span>,sum-<span class="number">5</span>)+dicesSumCore(n-<span class="number">1</span>,sum-<span class="number">6</span>);</span><br><span class="line">	    <span class="keyword">return</span> resCount;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><p>使用递归求解会产生大量重复的计算，所以使用动态规划更好。</p>
<p>在以下代码中使用了一个二维数组dp[2][maxSum+1]，dp[0]和dp[1]表示当前状态和前一个状态（由状态转移方程<code>f(n,s)=f(n-1,s-1)+f(n-1,s-2)+f(n-1,s-3)+f(n-1,s-4)+f(n-1,s-5)+f(n-1,s-6)</code>可以看出当前状态仅依赖前一个状态，所以只用两个一维数组即可），而这两个状态的数组使用flag变量进行旋转。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> List&lt;Map.Entry&lt;Integer, Double&gt;&gt; dicesSum(<span class="keyword">int</span> n) &#123;</span><br><span class="line">		List&lt;Map.Entry&lt;Integer, Double&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		<span class="keyword">if</span>(n &lt; <span class="number">1</span>)</span><br><span class="line">			<span class="keyword">return</span> result;</span><br><span class="line">		<span class="keyword">int</span> face = <span class="number">6</span>;</span><br><span class="line">		<span class="keyword">int</span> minSum = n;</span><br><span class="line">		<span class="keyword">int</span> maxSum = face * n;</span><br><span class="line">		<span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">double</span> totalCase = Math.pow(face, n);    <span class="comment">//总共有6的n次方种排列情况</span></span><br><span class="line">		<span class="keyword">long</span>[][] dp = <span class="keyword">new</span> <span class="keyword">long</span>[<span class="number">2</span>][maxSum+<span class="number">1</span>];	 <span class="comment">//dp[flag][j]表示当前状态下产生点数和为j的排列次数</span></span><br><span class="line">		</span><br><span class="line">	        <span class="comment">//设置初始状态，即f(1,1) = f(1,2) = f(1,3) = f(1,4) = f(1,5) = f(1,6) = 1</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= face; i++)</span><br><span class="line">			dp[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//i表示当前扔出的骰子数，骰子数为1的情况在上面已经有过初始化</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++, flag = <span class="number">1</span> - flag) &#123;</span><br><span class="line">			<span class="comment">//将表示当前状态的数组清零</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= maxSum; j++)</span><br><span class="line">	            dp[flag][j] = <span class="number">0</span>;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= maxSum; j++)</span><br><span class="line">	            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= face &amp;&amp; k &lt;= j; k++)</span><br><span class="line">		    	<span class="comment">//此处即体现出状态转移方程</span></span><br><span class="line">	                dp[flag][j] += dp[<span class="number">1</span> - flag][j - k];</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = minSum; i &lt;= maxSum; i++) &#123;</span><br><span class="line">			result.add(<span class="keyword">new</span> AbstractMap.SimpleEntry&lt;&gt;(i, dp[<span class="number">1</span> - flag][i] / totalCase));</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="61-扑克牌顺子"><a href="#61-扑克牌顺子" class="headerlink" title="61 扑克牌顺子"></a>61 扑克牌顺子</h2><h3 id="题目描述-67"><a href="#题目描述-67" class="headerlink" title="题目描述"></a>题目描述</h3><p>从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。大小王可看成任意数字。</p>
<h3 id="题解-67"><a href="#题解-67" class="headerlink" title="题解"></a>题解</h3><p>把大小王看成0，首先把数组排序，其次统计数组中0的个数，最后统计排序后的数组中相邻数字之间的空缺总数。如果空缺总数小于或者等于0的个数，那么这个数组就是连续的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isContinuous</span><span class="params">(<span class="keyword">int</span> [] numbers)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(numbers == <span class="keyword">null</span> || numbers.length == <span class="number">0</span>)</span><br><span class="line">    		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    	</span><br><span class="line">    	<span class="keyword">int</span> numOfZero = <span class="number">0</span>;</span><br><span class="line">    	<span class="keyword">int</span> numOfGap = <span class="number">0</span>;</span><br><span class="line">    	</span><br><span class="line">    	Arrays.sort(numbers);</span><br><span class="line">    	</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numbers.length &amp;&amp; numbers[i] == <span class="number">0</span>; i++) &#123;</span><br><span class="line">    		numOfZero++;</span><br><span class="line">    	&#125;</span><br><span class="line">    	</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i = numOfZero+<span class="number">1</span>; i &lt; numbers.length; i++) &#123;</span><br><span class="line">    		<span class="keyword">if</span>(numbers[i] == numbers[i-<span class="number">1</span>])</span><br><span class="line">    			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    		numOfGap += numbers[i] - numbers[i-<span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span> numOfZero &gt;= numOfGap ? <span class="keyword">true</span> : <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="62-圆圈中最后剩下的数字"><a href="#62-圆圈中最后剩下的数字" class="headerlink" title="62 圆圈中最后剩下的数字"></a>62 圆圈中最后剩下的数字</h2><h3 id="题目描述-68"><a href="#题目描述-68" class="headerlink" title="题目描述"></a>题目描述</h3><p>首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0…m-1报数….这样下去….直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1)</p>
<h3 id="题解-68"><a href="#题解-68" class="headerlink" title="题解"></a>题解</h3><h4 id="环形链表法"><a href="#环形链表法" class="headerlink" title="环形链表法"></a>环形链表法</h4><p>采用链表来模拟整个过程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">LastRemaining_Solution</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">1</span> || m &lt; <span class="number">1</span>)</span><br><span class="line">    		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    	</span><br><span class="line">        LinkedList&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        	list.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(list.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        	index = (index + m - <span class="number">1</span>) % list.size();</span><br><span class="line">        	list.remove(index);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="公式法"><a href="#公式法" class="headerlink" title="公式法"></a>公式法</h4><p>我们可以根据此公式使用递归或者循环来做：<code>f(n,m) = [f(n-1,m) + m] % n</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">LastRemaining_Solution</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">	        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	    <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">	        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	    <span class="keyword">return</span> (LastRemaining_Solution(n - <span class="number">1</span>, m) + m) % n;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="63-股票的最大利润"><a href="#63-股票的最大利润" class="headerlink" title="63 股票的最大利润"></a>63 股票的最大利润</h2><h3 id="题目描述-69"><a href="#题目描述-69" class="headerlink" title="题目描述"></a>题目描述</h3><p>假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可获得的最大利润是多少？</p>
<h3 id="题解-69"><a href="#题解-69" class="headerlink" title="题解"></a>题解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaximalProfit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices == <span class="keyword">null</span> || prices.length == <span class="number">0</span>)</span><br><span class="line">        	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> minPrice = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> maxProfit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">        	<span class="keyword">if</span>(prices[i] &lt; minPrice)</span><br><span class="line">        		minPrice = prices[i];</span><br><span class="line">        	<span class="keyword">int</span> currProfit = prices[i] - minPrice;</span><br><span class="line">        	<span class="keyword">if</span>(currProfit &gt; maxProfit)</span><br><span class="line">        		maxProfit = currProfit;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxProfit;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="64-求1-2-···-n"><a href="#64-求1-2-···-n" class="headerlink" title="64 求1+2+···+n"></a>64 求1+2+···+n</h2><h3 id="题目描述-70"><a href="#题目描述-70" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="题解-70"><a href="#题解-70" class="headerlink" title="题解"></a>题解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Sum_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = n;</span><br><span class="line">    	<span class="keyword">boolean</span> flag = (sum &gt; <span class="number">0</span>) &amp;&amp; ((sum += Sum_Solution(--n)) &gt; <span class="number">0</span>);</span><br><span class="line">    	<span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="65-不用加减乘除做加法"><a href="#65-不用加减乘除做加法" class="headerlink" title="65 不用加减乘除做加法"></a>65 不用加减乘除做加法</h2><h3 id="题目描述-71"><a href="#题目描述-71" class="headerlink" title="题目描述"></a>题目描述</h3><p>写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。</p>
<h3 id="题解-71"><a href="#题解-71" class="headerlink" title="题解"></a>题解</h3><p>十进制加法三步走：<br>1、只做各位相加不进位<br>2、求出进位值<br>3、把前面两个结果加起来</p>
<p>而对于二进制也正是如此。使用异或完成相加的操作，而使用位与运算再左移完成进位的操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> num1,<span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum, carry;</span><br><span class="line">    	<span class="keyword">do</span> &#123;</span><br><span class="line">    		 sum = num1 ^ num2;</span><br><span class="line">    		 carry = (num1 &amp; num2) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    		 num1 = sum;</span><br><span class="line">    		 num2 = carry;</span><br><span class="line">    	&#125; <span class="keyword">while</span>(carry != <span class="number">0</span>);</span><br><span class="line">    	<span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><p>不使用新变量交换两个变量的值:</p>
<table>
<thead>
<tr>
<th>基于加减法</th>
<th>基于异或运算</th>
</tr>
</thead>
<tbody>
<tr>
<td>a = a + b</td>
<td>a = a ^ b</td>
</tr>
<tr>
<td>b = a - b</td>
<td>a = a ^ b</td>
</tr>
<tr>
<td>a = a - b</td>
<td>a = a ^ b</td>
</tr>
</tbody>
</table>
<h2 id="66-构建乘积数组"><a href="#66-构建乘积数组" class="headerlink" title="66 构建乘积数组"></a>66 构建乘积数组</h2><h3 id="题目描述-72"><a href="#题目描述-72" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0] <em> A[1] </em> … <em> A[i-1] </em> A[i+1] <em> … </em> A[n-1]。不能使用除法。</p>
<h3 id="题解-72"><a href="#题解-72" class="headerlink" title="题解"></a>题解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] multiply(<span class="keyword">int</span>[] A) &#123;</span><br><span class="line">    	<span class="keyword">int</span>[] B = <span class="keyword">new</span> <span class="keyword">int</span>[A.length];</span><br><span class="line">    	<span class="keyword">if</span>(A == <span class="keyword">null</span> || A.length == <span class="number">0</span>)</span><br><span class="line">    		<span class="keyword">return</span> B;</span><br><span class="line">    	</span><br><span class="line">    	B[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; A.length; i++) &#123;</span><br><span class="line">    		B[i] = B[i-<span class="number">1</span>] * A[i-<span class="number">1</span>];</span><br><span class="line">    	&#125;</span><br><span class="line">    	</span><br><span class="line">    	<span class="keyword">int</span> temp = <span class="number">1</span>;</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i = B.length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">    		temp = A[i+<span class="number">1</span>] * temp;</span><br><span class="line">    		B[i] = temp * B[i];</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span> B;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="67-把字符串转换成整数"><a href="#67-把字符串转换成整数" class="headerlink" title="67 把字符串转换成整数"></a>67 把字符串转换成整数</h2><h3 id="题目描述-73"><a href="#题目描述-73" class="headerlink" title="题目描述"></a>题目描述</h3><p>将一个字符串转换成一个整数(实现Integer.valueOf(string)的功能，但是string不符合数字要求时返回0)，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0。</p>
<h3 id="题解-73"><a href="#题解-73" class="headerlink" title="题解"></a>题解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">StrToInt</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str == <span class="keyword">null</span> || str.length() == <span class="number">0</span>)</span><br><span class="line">        	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span> neg = str.charAt(<span class="number">0</span>) == <span class="string">'-'</span>;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">        	<span class="keyword">char</span> c = str.charAt(i);</span><br><span class="line">        	<span class="keyword">if</span>(i == <span class="number">0</span> &amp;&amp; (c == <span class="string">'+'</span> || c == <span class="string">'-'</span>)) <span class="keyword">continue</span>;</span><br><span class="line">        	<span class="keyword">if</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        	<span class="keyword">int</span> temp = num;</span><br><span class="line">        	num = num * <span class="number">10</span> + (c - <span class="string">'0'</span>);</span><br><span class="line">            <span class="keyword">if</span>((num - c + <span class="string">'0'</span>) / <span class="number">10</span> != temp) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> neg ? -num : num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="68-1-二叉查找树中两个节点的最低公共祖先"><a href="#68-1-二叉查找树中两个节点的最低公共祖先" class="headerlink" title="68.1 二叉查找树中两个节点的最低公共祖先"></a>68.1 二叉查找树中两个节点的最低公共祖先</h2><h3 id="题目描述-74"><a href="#题目描述-74" class="headerlink" title="题目描述"></a>题目描述</h3><p>找到二叉查找树中两个节点的最低公共祖先</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>
<h3 id="题解-74"><a href="#题解-74" class="headerlink" title="题解"></a>题解</h3><p>从根节点开始向下查找直到找到满足<code>root.val &gt;= p.val</code>且<code>root.val &lt;= q.val</code>的节点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">while</span>(root != <span class="keyword">null</span>) &#123;</span><br><span class="line">    		<span class="keyword">if</span>(root.val &gt; p.val &amp;&amp; root.val &gt; q.val)</span><br><span class="line">    			root = root.left;</span><br><span class="line">	        <span class="keyword">else</span> <span class="keyword">if</span>(root.val &lt; p.val &amp;&amp; root.val &lt; q.val)</span><br><span class="line">	        	root = root.right;</span><br><span class="line">	        <span class="keyword">else</span> </span><br><span class="line">	        	<span class="keyword">return</span> root;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="68-2-普通二叉树中两个节点的最低公共祖先"><a href="#68-2-普通二叉树中两个节点的最低公共祖先" class="headerlink" title="68.2 普通二叉树中两个节点的最低公共祖先"></a>68.2 普通二叉树中两个节点的最低公共祖先</h2><h3 id="题目描述-75"><a href="#题目描述-75" class="headerlink" title="题目描述"></a>题目描述</h3><p>找到普通二叉树中两个节点的最低公共祖先</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>
<h3 id="题解-75"><a href="#题解-75" class="headerlink" title="题解"></a>题解</h3><p>深度优先搜索的思想：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(root == <span class="keyword">null</span> || root.val == p.val || root.val == q.val)</span><br><span class="line">    		<span class="keyword">return</span> root;</span><br><span class="line">    	</span><br><span class="line">    	TreeNode left = lowestCommonAncestor(root.left, p, q);</span><br><span class="line">    	TreeNode right = lowestCommonAncestor(root.right, p, q);</span><br><span class="line">    	<span class="keyword">return</span> left == <span class="keyword">null</span> ? right : right == <span class="keyword">null</span> ? left : root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
        </div>

        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/算法/"># 算法</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2019/01/29/设计模式/">设计模式</a>
            
            
            <a class="next" rel="next" href="/2019/01/28/MySQL查询性能优化/">MySQL查询性能优化</a>
            
        </section>


    </article>
</div>

        </div>
        <footer id="footer" class="footer">
    <div class="copyright">
        <span>© 水木今山 | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>
</html>
